# t1.larek.tech

Добро пожаловать на сервис t1.larek.tech! В этом руководстве вы найдете инструкции по авторизации и входу через email и пароль, а также описание основных функциональностей системы.

## Авторизация и вход

### Шаг 1: Перейдите на страницу входа

Перейдите на страницу входа по следующему адресу: [t1.larek.tech/login](https://t1.larek.tech/login).

### Шаг 2: Введите свои учетные данные

Введите свой email и пароль в соответствующие поля и нажмите кнопку "Войти".

![Скриншот страницы входа](docs/login_screenshot.png)

### Шаг 3: Доступ к сервису

После успешного входа вы получите доступ к сервису t1.larek.tech. Теперь вы можете использовать все доступные функции и возможности.

## Основные функциональности

### Все вакансии

На этой странице вы можете просматривать все доступные вакансии.

![Скриншот страницы "Все вакансии"](docs/Все%20вакансии.png)

### Вакансия

На этой странице вы можете просматривать детали конкретной вакансии.

![Скриншот страницы "Вакансия"](docs/Вакансия.png)

### Вакансия кандидаты

На этой странице вы можете просматривать кандидатов, связанных с конкретной вакансией.

![Скриншот страницы "Вакансия кандидаты"](docs/Вакансия%20кандидаты.png)

### Задачи

На этой странице вы можете управлять задачами, связанными с вакансиями и кандидатами.

![Скриншот страницы "Задачи"](docs/задачи.png)

## Документация

Для получения дополнительной информации о работе [api](https://api.t1.larek.tech/docs#/). 



![Скриншот документации](docs/docs.png)

## Поддержка

Если у вас возникли вопросы или проблемы, пожалуйста, свяжитесь с нашей службой поддержки по email: support@larek.tech.

## Сбор данных

Для сбора данных использовали источник сайта https://career.t1.ru/vacancies, где клиент выполняет запросы к api hh.ru для получения актуальной информации о вакансиях t1.
Для доступа к данным использовали Bearer Token который передается в authorization header запроса от клиента см изображение ниже 

![hh](docs/hh.png)

по итогу получили формат запроса:
```bash
curl 'https://api.hh.ru/vacancies?employer_id=4649269&page=0&per_page=8&search_field=name&professional_role=26&professional_role=36&professional_role=73&professional_role=125' \
  -H 'accept: application/json, text/plain, */*' \
  -H 'accept-language: en-US,en;q=0.9,ru-RU;q=0.8,ru;q=0.7' \
  -H 'authorization: Bearer APPLRMJQHCQCST4PURJJ3DBU9LTHKUUQT2R1VSP8BKTOS3OLP46AQTDCMG42NA34' \
  -H 'dnt: 1' \
  -H 'origin: https://career.t1.ru' \
  -H 'priority: u=1, i' \
  -H 'referer: https://career.t1.ru/' \
  -H 'sec-ch-ua: "Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "macOS"' \
  -H 'sec-fetch-dest: empty' \
  -H 'sec-fetch-mode: cors' \
  -H 'sec-fetch-site: cross-site' \
  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36'
```

в котором изменяя query параметры получали данные о вакансиях описание и метаданные получали из следующего экрана (запроса)

![hh](docs/hh2.png)

```bash
curl 'https://api.hh.ru/vacancies/106757940' \
  -H 'accept: application/json, text/plain, */*' \
  -H 'accept-language: en-US,en;q=0.9,ru-RU;q=0.8,ru;q=0.7' \
  -H 'dnt: 1' \
  -H 'origin: https://career.t1.ru' \
  -H 'priority: u=1, i' \
  -H 'referer: https://career.t1.ru/' \
  -H 'sec-ch-ua: "Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "macOS"' \
  -H 'sec-fetch-dest: empty' \
  -H 'sec-fetch-mode: cors' \
  -H 'sec-fetch-site: cross-site' \
  -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36'
```

в ответ на который мы получали json из которого брали интересующие параметры
```json
{
    "id": "106757940",
    "premium": false,
    "billing_type": {
        "id": "standard",
        "name": "Стандарт"
    },
    "relations": [],
    "name": "Администратор проекта (направление продуктовой разработки)",
    "insider_interview": null,
    "response_letter_required": false,
    "area": {
        "id": "1",
        "name": "Москва",
        "url": "https://api.hh.ru/areas/1"
    },
    "salary": null,
    "type": {
        "id": "open",
        "name": "Открытая"
    },
    "address": {
        "city": null,
        "street": null,
        "building": null,
        "lat": null,
        "lng": null,
        "description": null,
        "raw": null,
        "metro": {
            "station_name": "Деловой центр",
            "line_name": "Большая кольцевая линия",
            "station_id": "97.603",
            "line_id": "97",
            "lat": 55.7491,
            "lng": 37.5395
        },
        "metro_stations": [
            {
                "station_name": "Деловой центр",
                "line_name": "Большая кольцевая линия",
                "station_id": "97.603",
                "line_id": "97",
                "lat": 55.7491,
                "lng": 37.5395
            }
        ]
    },
    "allow_messages": true,
    "experience": {
        "id": "between1And3",
        "name": "От 1 года до 3 лет"
    },
    "schedule": {
        "id": "fullDay",
        "name": "Полный день"
    },
    "employment": {
        "id": "full",
        "name": "Полная занятость"
    },
    "department": {
        "id": "4649269-4649269-innoteh",
        "name": "ГК Иннотех | Финтех (Иннотех)"
    },
    "contacts": null,
    "description": "<strong>Обязанности:</strong> <ul> <li>Актуализация и контроль плана развития, видения и продвижения Программных продуктов (ПП);</li> <li>Подготовка, свод, подтверждение артефактов поставки по аддонам;</li> <li>Формирование комплектов поставки по ПП;</li> <li>Поддержка в актуальном состоянии информации о ПП на внутренних и внешних ресурсах;</li> <li>Сбор требований/целей/задач/контрольных точек проекта;</li> <li>Взаимодействие с ИТ-лидерами стримов.</li> </ul> <strong>Требования:</strong> <ul> <li>Опыт работы с программными продуктами или проектами в качестве администратора или менеджера продукта от 1 года;</li> <li>Навыки работы с инструментами проектирования задач с учетом затраченного времени (Jira, Redmine, OpenProject и т.д.);</li> <li>Опыт работы с договорами/соглашениями и взаимодействия с методологами, юристами, аудиторами;</li> <li>Опыт планирования и расчета ресурсов (людских/железных);</li> <li>Навык подготовки отчетов и закрывающих документов по продукту и/или проекту;</li> <li>Знание принципов и практик управления проектами: (Scrum, Agile, Kanban, Waterfall).</li> </ul>",
    "branded_description": "<style>\n    /** @format */\n    .hht-vacancydescription {\n      padding: 0;\n    }\n    .tmpl_hh_wrapper {\n      width: 100%;\n      margin: 0 auto;\n      max-width: 690px;\n      position: relative;\n      word-break: normal;\n      overflow: hidden;\n      font-weight: 400;\n      font-size: 16px;\n      line-height: 22px;\n      letter-spacing: 0.01em;\n      z-index: 1;\n    }\n    @media (max-width: 1019px) {\n      .tmpl_hh_wrapper {\n        max-width: 610px;\n      }\n    }\n    .tmpl_hh_wrapper p, .tmpl_hh_wrapper h1, .tmpl_hh_wrapper h2, .tmpl_hh_wrapper h3, .tmpl_hh_wrapper h4, .tmpl_hh_wrapper h5, .tmpl_hh_wrapper h6, .tmpl_hh_wrapper a, .tmpl_hh_wrapper img, .tmpl_hh_wrapper ol, .tmpl_hh_wrapper ul, .tmpl_hh_wrapper li {\n      margin: 0;\n      padding: 0;\n      border: 0;\n      font: inherit;\n      vertical-align: baseline;\n    }\n    .tmpl_hh_wrapper ul {\n      list-style: none;\n    }\n    .tmpl_hh_wrapper a {\n      text-decoration: none;\n    }\n    .tmpl_hh_wrapper a:hover {\n      color: inherit;\n    }\n    .tmpl_hh_wrapper img {\n      display: block;\n    }\n    .tmpl_hh_wrapper button {\n      display: block;\n      border: none;\n      background-color: transparent;\n      cursor: pointer;\n      outline: none;\n      padding: 0;\n    }\n    .tmpl_hh_wrapper button svg {\n      cursor: pointer;\n    }\n    .tmpl_hh_wrapper .l-cell, .tmpl_hh_wrapper .l-paddings {\n      padding: 0 !important;\n    }\n    .tmpl_hh_wrapper .b-vacancy-desc-wrapper {\n      margin-top: 0 !important;\n    }\n    .tmpl_hh_wrapper .b-vacancy-desc {\n      overflow: visible !important;\n      line-height: inherit;\n    }\n    .tmpl_hh_content ol li b, .tmpl_hh_content ol li strong, .tmpl_hh_content ol li p b, .tmpl_hh_content ol li p strong, .tmpl_hh_content ul li b, .tmpl_hh_content ul li strong, .tmpl_hh_content ul li p b, .tmpl_hh_content ul li p strong {\n      font-weight: normal;\n      font-size: inherit !important;\n      color: inherit !important;\n      margin: 0 !important;\n      text-transform: none;\n      line-height: inherit;\n    }\n    .tmpl_hh_content ol li p, .tmpl_hh_content ul li p {\n      font-weight: normal;\n      margin: 0;\n    }\n    .tmpl_hh_content p {\n      margin-bottom: 16px;\n    }\n    .tmpl_hh_content p b, .tmpl_hh_content p strong {\n      display: inline;\n      margin: 0;\n    }\n    .tmpl_hh_content ol, .tmpl_hh_content ul {\n      margin-left: 18px;\n      margin-bottom: 32px;\n      list-style: none !important;\n    }\n    .tmpl_hh_content ol {\n      counter-reset: list_counter;\n    }\n    .tmpl_hh_content li {\n      position: relative;\n      margin-bottom: 8px;\n      font-size: 16px;\n    }\n    .tmpl_hh_content li:last-child {\n      margin-bottom: 0;\n    }\n    .tmpl_hh_content ul ul, .tmpl_hh_content ul ol, .tmpl_hh_content ol ol, .tmpl_hh_content ol ul {\n      margin-top: 14px;\n    }\n    .tmpl_hh_content ol > li {\n      counter-increment: list_counter;\n    }\n    .tmpl_hh_content ul > li:before {\ncontent: \"\";\n    background-image: url(\"https://hhcdn.ru/ichameleon/362428.svg\");\n    background-repeat: no-repeat;\n    background-size: 100% auto;\n    background-position: center;\n  position: absolute;\n  top: 4px;\n  left: -18px;\n  width: 10px;\n  height: 10px;} .tmpl_hh_content ol > li::before {\n  content: counter(list_counter) \".\";\n  right: 100%;\n  left: auto;\n  margin-right: 2px;\n    }\n    .tmpl_hh_content ol > li:before {\n      content: counter(list_counter) \".\";\n      left: auto;\n      right: 100%;\n      margin-right: 2px;\n    }\n    .tmpl_hh_content :last-child {\n      margin-bottom: 0;\n    }\n    /* stylelint-disable block-no-empty */\n    /* stylelint-enable block-no-empty */\n    .tmpl_hh_wrapper {\n      box-sizing: border-box;\n      color: #030126;\n      font-size: 18px;\n      font-family: Arial, sans-serif;\n      line-height: 27px;\n    }\n    .tmpl_hh_wrapper .tmpl_hh_designation {\n      color: #c1c3c7;\n      font-size: 14px;\n      line-height: 20px;\n    }\n    .tmpl_hh_flex {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n    .tmpl_hh_header {\n      display: flex;\n      flex-wrap: wrap;\n      align-content: space-between;\n      box-sizing: border-box;\n      height: 369px;\n      padding: 25px 30px 30px;\n      border-radius: 5px 5px 0 0;\n      background: url(\"https://hhcdn.ru/ichameleon/362400.jpg\") center/cover no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_header {\n        height: auto;\n        padding: 15px 20px 20px;\n    \n      }\n    }\n    .tmpl_hh_header-title {\n      width: 100%;\n      height: auto;\n    max-width: 512px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_header-title {\n        margin-bottom: 170px;\n      }\n    }\n    .tmpl_hh_header > p {\n      width: 100%;\n      color: #fff;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_aside-first {\n      padding: 50px 30px 25px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first {\n        padding: 50px 20px;\n      }\n    }\n    .tmpl_hh_aside-first > h2 {\n      margin-bottom: 30px;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > h2 {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_aside-first > ul {\n      display: flex;\n      gap: 10px;\n      margin-bottom: 20px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > ul {\n        flex-wrap: wrap;\n      }\n    }\n    .tmpl_hh_aside-first > ul > li {\n      display: flex;\n      flex-grow: 1;\n      flex-direction: column;\n      gap: 20px;\n      box-sizing: border-box;\n      width: 33%;\n      padding: 15px;\n      border-radius: 10px;\n      background: #ecf0ff;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first > ul > li {\n        width: 100%;\n      }\n    }\n    .tmpl_hh_aside-first > ul > li > img {\n      width: 120px;\n      height: 88px;\n    }\n    .tmpl_hh_aside-first > ul > li > p {\n      font-size: 16px;\n      line-height: 130%;\n    }\n    .tmpl_hh_aside-first-ft {\n      display: flex;\n      flex-direction: column;\n      gap: 5px;\n      margin-bottom: 30px;\n      color: #c1c3c7;\n      font-size: 13px;\n      line-height: 115%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first-ft {\n        font-size: 14px;\n      }\n    }\n    .tmpl_hh_aside-first-ft > p:last-of-type {\n      padding-left: 5px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-first-ft > p:last-of-type {\n        padding: 0;\n      }\n    }\n    .tmpl_hh_aside-first-text {\n      display: flex;\n      flex-direction: column;\n      gap: 30px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_aside-first-text > p:last-of-type {\n      margin-top: -10px;\n    }\n    .tmpl_hh_aside-second {\n      padding: 25px 30px 50px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second {\n        padding: 50px 20px;\n      }\n    }\n    .tmpl_hh_aside-second > h3 {\n      margin-bottom: 30px;\n      color: #00AAE6;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > h3 {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_aside-second > p {\n      margin-bottom: 30px;\n      font-size: 16px;\n      line-height: 130%;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper {\n      margin-bottom: 50px;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide {\n      width: 100%;\n      padding-top: 49.2063492063%;\n      border-radius: 15px;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-1 {\n      background: url(\"https://hhcdn.ru/ichameleon/332876.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-2 {\n      background: url(\"https://hhcdn.ru/ichameleon/332877.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-3 {\n      background: url(\"https://hhcdn.ru/ichameleon/332878.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-4 {\n      background: url(\"https://hhcdn.ru/ichameleon/332879.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__slide-5 {\n      background: url(\"https://hhcdn.ru/ichameleon/332875.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__btns {\n      position: absolute;\n      top: 0;\n      left: 0;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      width: 100%;\n      height: 100%;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__button-prev, .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n      position: relative;\n      z-index: 9;\n      width: 32px;\n      height: 32px;\n      margin: 0 20px;\n      background: url(\"https://hhcdn.ru/ichameleon/332872.png\") center/contain no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__button-prev, .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n        width: 18px;\n        height: 18px;\n        margin: 0 10px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__button-next {\n      background: url(\"https://hhcdn.ru/ichameleon/332873.png\") center/contain no-repeat;\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination {\n      position: absolute;\n      bottom: 20px;\n      left: 0;\n      display: flex;\n      gap: 10px;\n      justify-content: center;\n      width: 100%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__pagination {\n        bottom: 10px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet {\n      position: relative;\n      z-index: 9;\n      width: 50px;\n      height: 5px;\n      border-radius: 100px;\n      background: #fff;\n      cursor: pointer;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet {\n        width: 28px;\n        height: 2px;\n        border-radius: 50px;\n      }\n    }\n    .tmpl_hh_aside-second .tmpl_hh_swiper__pagination-bullet-active {\n      background: #00AAE6;\n    }\n    .tmpl_hh_aside-second > ul {\n      display: flex;\n      flex-wrap: wrap;\n      gap: 20px;\n    }\n    .tmpl_hh_aside-second > ul > li {\n      display: flex;\n      flex-grow: 1;\n      flex-direction: column;\n      gap: 15px;\n      width: calc(50% - 20px);\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > ul > li {\n        width: 100%;\n      }\n    }\n    .tmpl_hh_aside-second > ul > li > img {\n      width: 62px;\n      height: 62px;\n    }\n    .tmpl_hh_aside-second > ul > li > p {\n      color: #8a9aaa;\n      font-size: 14px;\n      line-height: 115%;\n    }\n    .tmpl_hh_aside-second > ul > li > p > b {\n      color: #030126;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_aside-second > ul > li > p br {\n        display: none;\n      }\n    }\n    .tmpl_hh_content {\n      padding-right: 30px;\n      padding-left: 30px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content {\n        padding-right: 20px;\n        padding-left: 20px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_vacancy-title {\n      margin-bottom: 30px;\n      color: #00AAE6;\n      font-weight: 700;\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_vacancy-title {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title, .tmpl_hh_content b.tmpl_hh_content_title, .tmpl_hh_content strong.tmpl_hh_content_title {\n      margin-bottom: 24px;\n      color: #00AAE6;\n      font-weight: 700;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title, .tmpl_hh_content b.tmpl_hh_content_title, .tmpl_hh_content strong.tmpl_hh_content_title {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > em, .tmpl_hh_content p.tmpl_hh_content_title > i, .tmpl_hh_content b.tmpl_hh_content_title > em, .tmpl_hh_content b.tmpl_hh_content_title > i, .tmpl_hh_content strong.tmpl_hh_content_title > em, .tmpl_hh_content strong.tmpl_hh_content_title > i {\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > em, .tmpl_hh_content p.tmpl_hh_content_title > i, .tmpl_hh_content b.tmpl_hh_content_title > em, .tmpl_hh_content b.tmpl_hh_content_title > i, .tmpl_hh_content strong.tmpl_hh_content_title > em, .tmpl_hh_content strong.tmpl_hh_content_title > i {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > b, .tmpl_hh_content p.tmpl_hh_content_title > strong {\n      color: #00AAE6;\n      font-weight: 700;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > b, .tmpl_hh_content p.tmpl_hh_content_title > strong {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p.tmpl_hh_content_title > b > em, .tmpl_hh_content p.tmpl_hh_content_title > b > i, .tmpl_hh_content p.tmpl_hh_content_title > strong > em, .tmpl_hh_content p.tmpl_hh_content_title > strong > i {\n      font-style: normal;\n      font-size: 20px;\n      line-height: 120%;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_content p.tmpl_hh_content_title > b > em, .tmpl_hh_content p.tmpl_hh_content_title > b > i, .tmpl_hh_content p.tmpl_hh_content_title > strong > em, .tmpl_hh_content p.tmpl_hh_content_title > strong > i {\n        font-size: 16px;\n      }\n    }\n    .tmpl_hh_content p {\n      margin-bottom: 20px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n    .tmpl_hh_content ul {\n      margin: 24px 0 30px 18px;\n    }\n    .tmpl_hh_content li {\n      margin-bottom: 24px;\n      font-size: 16px;\n      line-height: 120%;\n    }\n \n    .tmpl_hh_footer {\n      box-sizing: border-box;\n      padding: 20px 30px;\n      border-radius: 0 0 10px 10px;\n      background: url(\"https://hhcdn.ru/ichameleon/362409.jpg\") center/cover no-repeat;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_footer {\n        padding: 20px;\n \n      }\n    }\n    .tmpl_hh_footer-title {\n      width: 100%;\n      height: auto;\n      margin-bottom: 100px;\nmax-width: 423px;\n    }\n    @media (max-width: 655px) {\n      .tmpl_hh_footer-title {\n        margin-bottom: 95px;\n      }\n    }\n    .tmpl_hh_footer > p {\n      color: #fdfeff;\n      font-size: 14px;\n      line-height: 120%;\n      opacity: 0.5;\n    }/**\n     * Swiper 9.1.0\n     * Most modern mobile touch slider and framework with hardware accelerated transitions\n     * https://swiperjs.com\n     *\n     * Copyright 2014-2023 Vladimir Kharlampidi\n     *\n     * Released under the MIT License\n     *\n     * Released on: February 28, 2023\n     */\n    \n    @font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper,swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide,swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}\n    </style>\n    <div>\n        <div class=\"tmpl_hh_wrapper\">\n          <header class=\"tmpl_hh_header\">\n           <svg class=\"tmpl_hh_header-title\" width=\"513\" height=\"100\" viewBox=\"0 0 513 100\" fill=\"none\">\n    <path d=\"M506.197 49.5759H512.189V88.9999H505.581V57.0239L496.173 62.9599V56.2399L506.197 49.5759Z\" fill=\"white\"></path>\n    <path d=\"M462.133 49.5759H493.605V55.5679H481.229V88.9999H474.565V55.5679H462.133V49.5759Z\" fill=\"white\"></path>\n    <path d=\"M445.159 73.9359C447.847 74.6639 450.311 76.9599 450.311 80.8799C450.311 85.4719 446.783 88.9999 440.287 88.9999H426.903V60.4399H439.727C446.111 60.4399 449.135 63.6879 449.135 67.8319C449.135 71.1359 447.231 73.1519 445.159 73.9359ZM442.863 68.6159C442.863 66.4879 441.519 65.3679 438.943 65.3679H433.175V71.9759H438.943C441.463 71.9759 442.863 70.6879 442.863 68.6159ZM433.175 84.0719H439.503C442.415 84.0719 443.927 82.6719 443.927 80.3759C443.927 78.0799 442.415 76.7919 439.503 76.7919H433.175V84.0719Z\" fill=\"white\"></path>\n    <path d=\"M400.361 80.8799L407.865 60.4399H414.753L399.353 99.6959H392.521L396.945 88.4399L385.969 60.4399H392.857L400.361 80.8799Z\" fill=\"white\"></path>\n    <path d=\"M382.208 60.4399V83.3999H386.352V96.1679H380.192V88.9999H360.032V96.1679H353.872V83.3999H356.168C358.072 82.3359 359.024 78.8639 359.36 74.4959L360.424 60.4399H382.208ZM366.08 66.0399L365.408 74.7199C365.128 78.2479 364.792 81.4399 363.056 83.3999H375.824V66.0399H366.08Z\" fill=\"white\"></path>\n    <path d=\"M345.026 71.4159V60.4399H351.41V88.9999H345.026V77.0719H332.762V88.9999H326.378V60.4399H332.762V71.4159H345.026Z\" fill=\"white\"></path>\n    <path d=\"M309.471 59.7678C316.471 59.7678 321.119 63.5198 321.119 70.1838V88.9998H315.183V85.7518C313.223 88.2718 310.031 89.6718 306.335 89.6718C300.791 89.6718 296.423 86.3118 296.423 80.7118C296.423 75.0558 300.791 71.6958 307.903 71.6958H314.847V70.0718C314.847 66.7118 312.439 65.0318 309.247 65.0318C305.943 65.0318 304.207 66.5438 303.591 68.3358H297.543C298.383 63.6878 302.471 59.7678 309.471 59.7678ZM307.735 84.4638C311.543 84.4638 314.847 82.1118 314.847 78.2478V76.5118H308.351C305.103 76.5118 302.863 77.9118 302.863 80.4878C302.863 83.0638 304.879 84.4638 307.735 84.4638Z\" fill=\"white\"></path>\n    <path d=\"M275.588 81.1599L284.66 60.4399H292.612V88.9999H286.452V69.3999L277.884 88.8879H273.18L264.612 69.5119V88.9999H258.452V60.4399H266.516L275.588 81.1599Z\" fill=\"white\"></path>\n    <path d=\"M240.53 59.7678C248.93 59.7678 254.586 65.8718 254.586 74.7198C254.586 83.5678 248.93 89.6718 240.53 89.6718C232.13 89.6718 226.474 83.5678 226.474 74.7198C226.474 65.8718 232.13 59.7678 240.53 59.7678ZM240.53 84.0158C245.234 84.0158 248.09 80.2078 248.09 74.7198C248.09 69.2318 245.234 65.4238 240.53 65.4238C235.826 65.4238 232.97 69.2318 232.97 74.7198C232.97 80.2078 235.826 84.0158 240.53 84.0158Z\" fill=\"white\"></path>\n    <path d=\"M214.774 73.7679L227.262 88.9999H219.534L208.558 75.6719V88.9999H202.174V60.4399H208.558V72.3119L219.534 60.4399H227.094L214.774 73.7679Z\" fill=\"white\"></path>\n    <path d=\"M197.433 76.736H179.625V70.856H197.433V76.736Z\" fill=\"white\"></path>\n    <path d=\"M169.437 74.8879L179.349 88.9999H171.957L165.293 79.0879L158.629 88.9999H151.517L161.485 74.6639L151.629 60.4399H158.965L165.629 70.4639L172.181 60.4399H179.237L169.437 74.8879Z\" fill=\"white\"></path>\n    <path d=\"M151.129 73.9358V76.5678H131.025V76.6798C131.025 80.9918 134.105 84.3518 138.697 84.3518C142.113 84.3518 144.073 82.5598 144.521 81.2718H150.793C150.065 84.9118 146.369 89.6718 138.585 89.6718C130.129 89.6718 124.473 84.0158 124.473 74.7758C124.473 65.4798 130.129 59.7678 138.193 59.7678C146.033 59.7678 151.129 65.3118 151.129 73.9358ZM138.137 65.0878C134.105 65.0878 131.473 67.6638 131.081 71.7518H144.801C144.577 67.6078 142.113 65.0878 138.137 65.0878Z\" fill=\"white\"></path>\n    <path d=\"M99.3005 60.4399H123.941V66.0399H114.813V88.9999H108.429V66.0399H99.3005V60.4399Z\" fill=\"white\"></path>\n    <path d=\"M89.6707 71.4159V60.4399H96.0547V88.9999H89.6707V77.0719H77.4067V88.9999H71.0227V60.4399H77.4067V71.4159H89.6707Z\" fill=\"white\"></path>\n    <path d=\"M46.4488 79.4239L59.3848 60.4399H65.5448V88.9999H59.2728V70.0159L46.3368 88.9999H40.1768V60.4399H46.4488V79.4239Z\" fill=\"white\"></path>\n    <path d=\"M21.3852 49.24V59.824C30.0652 60.104 36.3372 65.984 36.3372 74.72C36.3372 83.456 30.0652 89.336 21.3852 89.616V99.696H15.1132V89.616C6.37722 89.336 0.105225 83.456 0.105225 74.72C0.105225 65.984 6.37722 60.104 15.1132 59.824V49.24H21.3852ZM15.1132 84.072V65.368C10.4092 65.48 6.54522 68.896 6.54522 74.72C6.54522 80.544 10.4092 83.96 15.1132 84.072ZM29.9532 74.72C29.9532 68.896 26.0892 65.48 21.3852 65.368V84.072C26.0332 83.96 29.9532 80.544 29.9532 74.72Z\" fill=\"white\"></path>\n    <path d=\"M417.253 11.7678C425.597 11.7678 431.085 17.9278 431.085 26.7198C431.085 35.5678 425.597 41.6718 417.253 41.6718C409.805 41.6718 404.485 36.6318 403.533 29.0718H398.829V40.9998H392.445V12.4398H398.829V23.4158H403.701C404.933 16.4158 410.141 11.7678 417.253 11.7678ZM417.253 36.0158C421.901 36.0158 424.645 32.2078 424.645 26.7198C424.645 21.2318 421.901 17.4238 417.253 17.4238C412.605 17.4238 409.861 21.2318 409.861 26.7198C409.861 32.2078 412.605 36.0158 417.253 36.0158Z\" fill=\"white\"></path>\n    <path d=\"M375.859 32.8799L383.363 12.4399H390.251L374.851 51.6959H368.019L372.443 40.4399L361.467 12.4399H368.355L375.859 32.8799Z\" fill=\"white\"></path>\n    <path d=\"M352.876 35.3999V12.4399H359.26V40.9999H321.292V12.4399H327.676V35.3999H337.084V12.4399H343.468V35.3999H352.876Z\" fill=\"white\"></path>\n    <path d=\"M309.429 24.4239V12.4399H315.813V40.9999H309.429V29.7439C307.861 30.6399 305.733 31.1999 303.045 31.1999C296.773 31.1999 291.901 27.6159 291.901 19.7199V12.4399H298.285V19.2719C298.285 23.5279 300.581 25.5999 304.501 25.5999C306.573 25.5999 308.197 25.0959 309.429 24.4239Z\" fill=\"white\"></path>\n    <path d=\"M276.267 32.8799L283.771 12.4399H290.659L275.259 51.6959H268.427L272.851 40.4399L261.875 12.4399H268.763L276.267 32.8799Z\" fill=\"white\"></path>\n    <path d=\"M237.234 29.5759L238.634 12.4399H259.634V40.9999H253.25V18.0399H244.29L243.282 30.0239C242.666 37.9199 239.754 41.1119 233.482 41.1119H231.746V35.5119H232.642C235.834 35.5119 236.898 33.8879 237.234 29.5759Z\" fill=\"white\"></path>\n    <path d=\"M202.3 33.1599L211.372 12.4399H219.324V40.9999H213.164V21.3999L204.596 40.8879H199.892L191.324 21.5119V40.9999H185.164V12.4399H193.228L202.3 33.1599Z\" fill=\"white\"></path>\n    <path d=\"M162.447 7.73593C160.319 7.73593 158.639 6.11193 158.639 3.98394C158.639 1.85593 160.319 0.231934 162.447 0.231934C164.575 0.231934 166.255 1.85593 166.255 3.98394C166.255 6.11193 164.575 7.73593 162.447 7.73593ZM174.319 7.73593C172.191 7.73593 170.511 6.11193 170.511 3.98394C170.511 1.85593 172.191 0.231934 174.319 0.231934C176.447 0.231934 178.127 1.85593 178.127 3.98394C178.127 6.11193 176.447 7.73593 174.319 7.73593ZM181.319 25.9359V28.5679H161.215V28.6799C161.215 32.9919 164.295 36.3519 168.887 36.3519C172.303 36.3519 174.263 34.5599 174.711 33.2719H180.983C180.255 36.9119 176.559 41.6719 168.775 41.6719C160.319 41.6719 154.663 36.0159 154.663 26.7759C154.663 17.4799 160.319 11.7679 168.383 11.7679C176.223 11.7679 181.319 17.3119 181.319 25.9359ZM168.327 17.0879C164.295 17.0879 161.663 19.6639 161.271 23.7519H174.991C174.767 19.6079 172.303 17.0879 168.327 17.0879Z\" fill=\"white\"></path>\n    <path d=\"M139.379 11.7678C146.379 11.7678 151.027 15.5198 151.027 22.1838V40.9998H145.091V37.7518C143.131 40.2718 139.939 41.6718 136.243 41.6718C130.699 41.6718 126.331 38.3118 126.331 32.7118C126.331 27.0558 130.699 23.6958 137.811 23.6958H144.755V22.0718C144.755 18.7118 142.347 17.0318 139.155 17.0318C135.851 17.0318 134.115 18.5438 133.499 20.3358H127.451C128.291 15.6878 132.379 11.7678 139.379 11.7678ZM137.643 36.4638C141.451 36.4638 144.755 34.1118 144.755 30.2478V28.5118H138.259C135.011 28.5118 132.771 29.9118 132.771 32.4878C132.771 35.0638 134.787 36.4638 137.643 36.4638Z\" fill=\"white\"></path>\n    <path d=\"M120.673 12.4399V35.3999H124.817V48.1679H118.657V40.9999H98.4967V48.1679H92.3367V35.3999H94.6327C96.5367 34.3359 97.4887 30.8639 97.8247 26.4959L98.8887 12.4399H120.673ZM104.545 18.0399L103.873 26.7199C103.593 30.2479 103.257 33.4399 101.521 35.3999H114.289V18.0399H104.545Z\" fill=\"white\"></path>\n    <path d=\"M74.0872 20.4478H67.9832C68.5992 14.7918 73.7512 11.7678 79.7992 11.7678C85.7912 11.7678 90.3272 14.9598 90.3272 19.9438C90.3272 23.4718 88.1993 25.3198 86.1833 26.1598C88.3673 26.6638 91.4473 28.5118 91.4473 32.7678C91.4473 38.0878 86.6312 41.6718 79.6872 41.6718C73.0792 41.6718 68.2072 38.3678 67.4792 32.5998H73.6953C74.3113 35.0638 76.6072 36.4078 79.6872 36.4078C82.9352 36.4078 85.0632 35.0078 85.0632 32.4878C85.0632 30.1358 83.2152 29.0158 79.7432 29.0158H75.5433V23.9758H79.4072C82.3752 23.9758 84.0553 22.6878 84.0553 20.4478C84.0553 18.2638 82.2073 17.0318 79.4632 17.0318C76.4392 17.0318 74.5912 18.4878 74.0872 20.4478Z\" fill=\"white\"></path>\n    <path d=\"M51.679 11.7678C60.079 11.7678 65.735 17.8718 65.735 26.7198C65.735 35.5678 60.079 41.6718 51.679 41.6718C43.279 41.6718 37.623 35.5678 37.623 26.7198C37.623 17.8718 43.279 11.7678 51.679 11.7678ZM51.679 36.0158C56.383 36.0158 59.239 32.2078 59.239 26.7198C59.239 21.2318 56.383 17.4238 51.679 17.4238C46.975 17.4238 44.119 21.2318 44.119 26.7198C44.119 32.2078 46.975 36.0158 51.679 36.0158Z\" fill=\"white\"></path>\n    <path d=\"M28.5533 28.0641H35.2733C34.6013 34.1681 29.4493 41.6721 18.5853 41.6721C8.11332 41.6721 0.497314 33.5521 0.497314 21.2881C0.497314 9.30405 7.88932 0.904053 18.5853 0.904053C28.4413 0.904053 34.0413 7.06405 35.1613 14.4561H28.4973C27.3773 10.4241 24.3533 7.00805 18.5853 7.00805C11.8093 7.00805 7.32932 12.7761 7.32932 21.2881C7.32932 29.6321 11.6973 35.5681 18.5853 35.5681C24.7453 35.5681 27.9373 31.3681 28.5533 28.0641Z\" fill=\"white\"></path>\n    </svg>\n    \n            <p><b>Финтех‑разработка</b></p>\n          </header>\n          <aside class=\"tmpl_hh_aside tmpl_hh_aside-first\">\n            <h2><b>Создаем технологии, определяя будущее</b></h2>\n              <ul>\n              <li>\n                <img src=\"https://hhcdn.ru/ichameleon/361888.png\" alt=\"item\">\n                <p>Т1 — один из лидеров* российского ИТ рынка, партнёр ключевых производителей и разработчиков в сфере ИТ</p>\n              </li>\n              <li>\n                <img src=\"https://hhcdn.ru/ichameleon/361889.png\" alt=\"item\">\n                <p>Предоставляет полный спектр услуг для реализации высокотехнологичных проектов для ключевых отраслей экономики</p>\n              </li>\n              <li>\n                <img src=\"https://hhcdn.ru/ichameleon/361890.png\" alt=\"item\">\n                <p>Входит в реестр аккредитованных ИТ‑компаний</p>\n              </li>\n            </ul>\n              <div class=\"tmpl_hh_aside-first-ft\">\n              <p>* Первое место среди ведущих российских ИКТ-компаний в рэнкинге RAEX 2023;</p>\n              <p> Первое место среди российских разработчиков ПО и интеграторов в рейтинге CNews100 2023</p>\n            </div>\n            <div class=\"tmpl_hh_aside-first-text\">\n              <p>В Т1 стабильность и финансовая надежность, а также социальные гарантии гармонично сочетаются с преимуществами ИТ‑компании — открытостью, инновациями и гибридным форматом работы.\n              </p>\n              <p><b>Мы стремительно растём, масштабируемся и ищем новых специалистов в команду!</b></p>\n              <p>В рамках финтех‑направления мы разрабатываем инновационные решения для цифровизации финансового сектора: современные финтех‑продукты, системы работы с большими данными и комплексные решения для фронт‑ и бэк‑офисов. В продуктовом портфеле — создание современных высоконагруженных фронтальных систем, омниканальных продуктов и высоконадежных платформ для поддержки банковского бизнеса.</p>\n              <p>Мы работаем с крупнейшими организациями банковского сектора, ведущими финансовыми компаниями и активно выстраиваем партнерскую работу на Ближнем Востоке, в Африке и Юго‑Восточной Азии. Охват пользователей продуктов составляет более 15 миллионов человек.</p>\n            </div>\n          </aside>\n          <main class=\"tmpl_hh_content\">\n            <strong>Обязанности:</strong> <ul> <li>Актуализация и контроль плана развития, видения и продвижения Программных продуктов (ПП);</li> <li>Подготовка, свод, подтверждение артефактов поставки по аддонам;</li> <li>Формирование комплектов поставки по ПП;</li> <li>Поддержка в актуальном состоянии информации о ПП на внутренних и внешних ресурсах;</li> <li>Сбор требований/целей/задач/контрольных точек проекта;</li> <li>Взаимодействие с ИТ-лидерами стримов.</li> </ul> <strong>Требования:</strong> <ul> <li>Опыт работы с программными продуктами или проектами в качестве администратора или менеджера продукта от 1 года;</li> <li>Навыки работы с инструментами проектирования задач с учетом затраченного времени (Jira, Redmine, OpenProject и т.д.);</li> <li>Опыт работы с договорами/соглашениями и взаимодействия с методологами, юристами, аудиторами;</li> <li>Опыт планирования и расчета ресурсов (людских/железных);</li> <li>Навык подготовки отчетов и закрывающих документов по продукту и/или проекту;</li> <li>Знание принципов и практик управления проектами: (Scrum, Agile, Kanban, Waterfall).</li> </ul></main>\n          <aside class=\"tmpl_hh_aside tmpl_hh_aside-second\">\n            <h3><b>Почему именно Т1?</b></h3>\n            <p>Мы создадим комфортные условия для работы, предложим интересные и масштабные задачи, а также поможем профессионально расти и развиваться, участвовать в кросс‑командных проектах и определять собственную траекторию развития.</p>\n            <div class=\"swiper tmpl_hh_swiper\">\n              <div class=\"swiper-wrapper tmpl_hh_swiper__wrapper\">\n                  <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-1\"> </div>\n                  <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-2\"> </div>\n                  <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-3\"> </div>\n                  <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-4\"> </div>\n                  <div class=\"swiper-slide tmpl_hh_swiper__slide tmpl_hh_swiper__slide-5\"> </div>\n              </div>\n            \n              <div class=\"swiper-pagination tmpl_hh_swiper__pagination\"></div>\n            \n              <div class=\"tmpl_hh_swiper__btns\">\n                  <button class=\"swiper-button-prev tmpl_hh_swiper__button tmpl_hh_swiper__button-prev\" type=\"button\"></button>\n                  <button class=\"swiper-button-next tmpl_hh_swiper__button tmpl_hh_swiper__button-next\" type=\"button\"></button>\n              </div>\n            </div>\n            <h3><b>Преимущества работы в Т1:</b></h3>\n            <ul>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362402.png\" alt=\"item\">\n      <p><b>Комфортные офисы <br>и гибкий рабочий день</b></p>\n      <p>В офисе, удаленно или в гибридном формате. Главный офис у м. Динамо в Москве — победитель в номинации «Гибкий офис» Best Office Awards 2023</p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362404.png\" alt=\"item\">\n      <p><b>ДМС и комплексные <br>программы поддержки</b></p>\n      <p>ДМС с телемедициной и возможностью подключения родственников и Добросервис для психологической, юридической и финансовой поддержки</p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362401.png\" alt=\"item\">\n      <p><b>Участие в конференциях <br>и профессиональное обучение</b></p>\n      <p>Бесплатное обучение, LMS платформа <br>с 70+ курсами для развития технических и коммуникационных навыков, программа наставничества, а также 12+ активных сообществ и техногильдий</p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362403.png\" alt=\"item\">\n      <p><b>Интересные задачи, производительное железо <br>и софт для работы</b></p>\n      <p>Востребованные на рынке ИТ‑продукты, ключевые ‑ уже внесены в ЕРРП (реестр российского ПО)</p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362408.png\" alt=\"item\">\n      <p><b>Насыщенная корпоративная <br>жизнь и нетворкинг</b></p>\n      <p>Масштабные таунхоллы и яркие неформальные события, регулярные митапы, корпоративная библиотека, активные сообщества и многое другое\n      </p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362405.png\" alt=\"item\">\n      <p><b>Скидки и партнерские<br> программы</b></p>\n      <p>Сервис привилегий от 100+ партнёров на покупку техники, занятия спортом и иностранными языками, концерты, отели, SPA и др. А также развитая программа компенсации и маркетплейс мерча с собственной корпоративной валютой</p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362407.png\" alt=\"item\">\n      <p><b>Конкурентная заработная плата</b></p>\n      <p>Достойный оклад по итогам интервью и система премирования. Оформление <br>по ТК и эксклюзивный зарплатный проект для сотрудников в банке ВТБ\n      </p>\n    </li>\n    <li>\n      <img src=\"https://hhcdn.ru/ichameleon/362406.png\" alt=\"item\">\n      <p><b>Дополнительные выходные и материальная помощь</b></p>\n      <p>Рождение ребёнка, поддержка многодетных семей и одиноких родителей, смерть членов семьи и др. Дополнительный оплачиваемый отпуск (3 календарных дня)</p>\n    </li>\n  </ul>\n          </aside>\n          <footer class=\"tmpl_hh_footer\">\n            \n              <svg class=\"tmpl_hh_footer-title\" width=\"423\" height=\"65\" viewBox=\"0 0 423 65\" fill=\"none\">\n<path d=\"M161.449 6.6C157.369 6.6 154.769 3.96 154.689 0H158.369C158.369 1.8 159.409 3.36 161.449 3.36C163.489 3.36 164.529 1.8 164.529 0H168.209C168.129 3.96 165.529 6.6 161.449 6.6Z\" fill=\"white\"></path>\n<path d=\"M156.849 22.8L166.089 9.24H170.489V29.64H166.009V16.08L156.769 29.64H152.369V9.24H156.849V22.8Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M362.953 19.44C362.953 13.12 358.913 8.76 352.913 8.76C346.913 8.76 342.873 13.12 342.873 19.44C342.873 25.76 346.913 30.12 352.913 30.12C358.913 30.12 362.953 25.76 362.953 19.44ZM358.313 19.44C358.313 23.36 356.273 26.08 352.913 26.08C349.553 26.08 347.513 23.36 347.513 19.44C347.513 15.52 349.553 12.8 352.913 12.8C356.273 12.8 358.313 15.52 358.313 19.44Z\" fill=\"white\"></path>\n<path d=\"M409.274 22.8L418.514 9.24H422.914V29.64H418.434V16.08L409.194 29.64H404.794V9.24H409.274V22.8Z\" fill=\"white\"></path>\n<path d=\"M162.387 35.48H184.867V39.76H176.027V63.64H171.267V39.76H162.387V35.48Z\" fill=\"white\"></path>\n<path d=\"M194.061 35.48H198.341V63.64H193.621V40.8L186.901 45.04V40.24L194.061 35.48Z\" fill=\"white\"></path>\n<path d=\"M149.283 56.68C148.883 58.24 147.643 60.08 144.723 60.08C141.523 60.08 139.443 57.44 139.443 53.44C139.443 49.52 141.443 46.8 144.683 46.8C147.483 46.8 148.763 48.6 149.243 50.12H153.683C153.203 46.48 150.203 42.76 144.683 42.76C138.643 42.76 134.803 47.32 134.803 53.44C134.803 59.64 138.683 64.12 144.683 64.12C149.923 64.12 153.283 60.68 153.723 56.68H149.283Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M125.705 52.88V54.76H111.345V54.84C111.345 57.92 113.545 60.32 116.825 60.32C119.265 60.32 120.665 59.04 120.985 58.12H125.465C124.945 60.72 122.305 64.12 116.745 64.12C110.705 64.12 106.665 60.08 106.665 53.48C106.665 46.84 110.705 42.76 116.465 42.76C122.065 42.76 125.705 46.72 125.705 52.88ZM116.425 46.56C113.545 46.56 111.665 48.4 111.385 51.32H121.185C121.025 48.36 119.265 46.56 116.425 46.56Z\" fill=\"white\"></path>\n<path d=\"M106.085 43.24H88.4847V47.24H95.0047V63.64H99.5647V47.24H106.085V43.24Z\" fill=\"white\"></path>\n<path d=\"M78.6822 60.08C81.6022 60.08 82.8422 58.24 83.2422 56.68H87.6822C87.2422 60.68 83.8822 64.12 78.6422 64.12C72.6422 64.12 68.7622 59.64 68.7622 53.44C68.7622 47.32 72.6022 42.76 78.6422 42.76C84.1622 42.76 87.1622 46.48 87.6422 50.12H83.2022C82.7222 48.6 81.4422 46.8 78.6422 46.8C75.4022 46.8 73.4022 49.52 73.4022 53.44C73.4022 57.44 75.4822 60.08 78.6822 60.08Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M66.9756 54.76V52.88C66.9756 46.72 63.3356 42.76 57.7356 42.76C51.9756 42.76 47.9356 46.84 47.9356 53.48C47.9356 60.08 51.9756 64.12 58.0156 64.12C63.5756 64.12 66.2156 60.72 66.7356 58.12H62.2556C61.9356 59.04 60.5356 60.32 58.0956 60.32C54.8156 60.32 52.6156 57.92 52.6156 54.84V54.76H66.9756ZM52.6556 51.32C52.9356 48.4 54.8156 46.56 57.6956 46.56C60.5356 46.56 62.2956 48.36 62.4556 51.32H52.6556Z\" fill=\"white\"></path>\n<path d=\"M32.8138 58.04L39.2938 43.24H44.9738V63.64H40.5737V49.64L34.4538 63.56H31.0938L24.9737 49.72V63.64H20.5737V43.24H26.3337L32.8138 58.04Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17.6 57.84C17.6 55.04 15.84 53.4 13.92 52.88C15.4 52.32 16.76 50.88 16.76 48.52C16.76 45.56 14.6 43.24 10.04 43.24H0.879999V63.64H10.44C15.08 63.64 17.6 61.12 17.6 57.84ZM9.48 46.76C11.32 46.76 12.28 47.56 12.28 49.08C12.28 50.56 11.28 51.48 9.48 51.48H5.36V46.76H9.48ZM9.88 60.12H5.36V54.92H9.88C11.96 54.92 13.04 55.84 13.04 57.48C13.04 59.12 11.96 60.12 9.88 60.12Z\" fill=\"white\"></path>\n<path d=\"M396.281 9.24L387.041 22.8V9.24H382.561V29.64H386.961L396.201 16.08V29.64H400.681V9.24H396.281Z\" fill=\"white\"></path>\n<path d=\"M365.914 9.24H379.914V13.24H370.474V29.64H365.914V9.24Z\" fill=\"white\"></path>\n<path d=\"M323.873 21.48L324.873 9.24H339.873V29.64H335.313V13.24H328.913L328.193 21.8C327.753 27.44 325.673 29.72 321.193 29.72H319.953V25.72H320.593C322.873 25.72 323.633 24.56 323.873 21.48Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M319.464 19.44C319.464 13.12 315.424 8.76 309.424 8.76C303.424 8.76 299.384 13.12 299.384 19.44C299.384 25.76 303.424 30.12 309.424 30.12C315.424 30.12 319.464 25.76 319.464 19.44ZM314.824 19.44C314.824 23.36 312.784 26.08 309.424 26.08C306.064 26.08 304.024 23.36 304.024 19.44C304.024 15.52 306.064 12.8 309.424 12.8C312.784 12.8 314.824 15.52 314.824 19.44Z\" fill=\"white\"></path>\n<path d=\"M291.866 17.08V9.24H296.426V29.64H291.866V21.12H283.106V29.64H278.546V9.24H283.106V17.08H291.866Z\" fill=\"white\"></path>\n<path d=\"M276.457 29.64L269.377 19.56L276.377 9.24H271.337L266.657 16.4L261.897 9.24H256.657L263.697 19.4L256.577 29.64H261.657L266.417 22.56L271.177 29.64H276.457Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M256.101 18.88V20.76H241.741V20.84C241.741 23.92 243.941 26.32 247.221 26.32C249.661 26.32 251.061 25.04 251.381 24.12H255.861C255.341 26.72 252.701 30.12 247.141 30.12C241.101 30.12 237.061 26.08 237.061 19.48C237.061 12.84 241.101 8.76 246.861 8.76C252.461 8.76 256.101 12.72 256.101 18.88ZM246.821 12.56C243.941 12.56 242.061 14.4 241.781 17.32H251.581C251.421 14.36 249.661 12.56 246.821 12.56Z\" fill=\"white\"></path>\n<path d=\"M236.48 9.24H218.88V13.24H225.4V29.64H229.96V13.24H236.48V9.24Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M210.222 18.88V20.76H195.862V20.84C195.862 23.92 198.062 26.32 201.342 26.32C203.782 26.32 205.182 25.04 205.502 24.12H209.982C209.462 26.72 206.822 30.12 201.262 30.12C195.223 30.12 191.182 26.08 191.182 19.48C191.182 12.84 195.222 8.76 200.982 8.76C206.582 8.76 210.222 12.72 210.222 18.88ZM200.942 12.56C198.062 12.56 196.182 14.4 195.902 17.32H205.702C205.542 14.36 203.782 12.56 200.942 12.56Z\" fill=\"white\"></path>\n<path d=\"M190.602 9.24H173.002V13.24H179.522V29.64H184.082V13.24H190.602V9.24Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M148.412 16.2C148.412 11.44 145.092 8.76 140.092 8.76C135.092 8.76 132.172 11.56 131.572 14.88H135.892C136.332 13.6 137.572 12.52 139.932 12.52C142.212 12.52 143.932 13.72 143.932 16.12V17.28H138.972C133.892 17.28 130.772 19.68 130.772 23.72C130.772 27.72 133.892 30.12 137.852 30.12C140.492 30.12 142.772 29.12 144.172 27.32V29.64H148.412V16.2ZM143.932 21.96C143.932 24.72 141.572 26.4 138.852 26.4C136.812 26.4 135.372 25.4 135.372 23.56C135.372 21.72 136.972 20.72 139.292 20.72H143.932V21.96Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M125.318 18.88C127.238 19.4 128.998 21.04 128.998 23.84C128.998 27.12 126.478 29.64 121.838 29.64H112.278V9.24H121.438C125.998 9.24 128.158 11.56 128.158 14.52C128.158 16.88 126.798 18.32 125.318 18.88ZM123.678 15.08C123.678 13.56 122.718 12.76 120.878 12.76H116.758V17.48H120.878C122.678 17.48 123.678 16.56 123.678 15.08ZM116.758 26.12H121.278C123.358 26.12 124.438 25.12 124.438 23.48C124.438 21.84 123.358 20.92 121.278 20.92H116.758V26.12Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M108.322 16.2C108.322 11.44 105.002 8.76 100.002 8.76C95.0016 8.76 92.0816 11.56 91.4816 14.88H95.8016C96.2416 13.6 97.4816 12.52 99.8416 12.52C102.122 12.52 103.842 13.72 103.842 16.12V17.28H98.8816C93.8016 17.28 90.6816 19.68 90.6816 23.72C90.6816 27.72 93.8016 30.12 97.7616 30.12C100.402 30.12 102.682 29.12 104.082 27.32V29.64H108.322V16.2ZM103.842 21.96C103.842 24.72 101.482 26.4 98.7616 26.4C96.7216 26.4 95.2816 25.4 95.2816 23.56C95.2816 21.72 96.8816 20.72 99.2016 20.72H103.842V21.96Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M86.4397 9.24V25.64H89.3997V34.76H84.9997V29.64H70.5997V34.76H66.1997V25.64H67.8397C69.1997 24.88 69.8797 22.4 70.1197 19.28L70.8797 9.24H86.4397ZM74.9197 13.24L74.4397 19.44C74.2397 21.96 73.9997 24.24 72.7597 25.64H81.8797V13.24H74.9197Z\" fill=\"white\"></path>\n<path d=\"M48.6044 14.96H52.9644C53.3244 13.56 54.6444 12.52 56.8044 12.52C58.7644 12.52 60.0844 13.4 60.0844 14.96C60.0844 16.56 58.8844 17.48 56.7644 17.48H54.0044V21.08H57.0044C59.4844 21.08 60.8044 21.88 60.8044 23.56C60.8044 25.36 59.2844 26.36 56.9644 26.36C54.7644 26.36 53.1244 25.4 52.6844 23.64H48.2444C48.7644 27.76 52.2444 30.12 56.9644 30.12C61.9244 30.12 65.3644 27.56 65.3644 23.76C65.3644 20.72 63.1644 19.4 61.6044 19.04C63.0444 18.44 64.5644 17.12 64.5644 14.6C64.5644 11.04 61.3244 8.76 57.0444 8.76C52.7244 8.76 49.0444 10.92 48.6044 14.96Z\" fill=\"white\"></path>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M36.7584 8.76C42.7584 8.76 46.7984 13.12 46.7984 19.44C46.7984 25.76 42.7584 30.12 36.7584 30.12C30.7584 30.12 26.7184 25.76 26.7184 19.44C26.7184 13.12 30.7584 8.76 36.7584 8.76ZM36.7584 26.08C40.1184 26.08 42.1584 23.36 42.1584 19.44C42.1584 15.52 40.1184 12.8 36.7584 12.8C33.3984 12.8 31.3584 15.52 31.3584 19.44C31.3584 23.36 33.3984 26.08 36.7584 26.08Z\" fill=\"white\"></path>\n<path d=\"M24.84 20.4H20.04C19.6 22.76 17.32 25.76 12.92 25.76C8 25.76 4.88 21.52 4.88 15.56C4.88 9.48 8.08 5.36 12.92 5.36C17.04 5.36 19.2 7.8 20 10.68H24.76C23.96 5.4 19.96 1 12.92 1C5.28 1 0 7 0 15.56C0 24.32 5.44 30.12 12.92 30.12C20.68 30.12 24.36 24.76 24.84 20.4Z\" fill=\"white\"></path>\n</svg>\n\n           <p>Команда рекрутмента<br> ООО «Группа компаний Иннотех» (входит в Т1)</p>\n          </footer>\n        </div>\n      </div>\n    <script>\n    //\n    \n    \n    const main = \"\";\n    const customTitle = () => {\n      const allUl = document.querySelectorAll(\".tmpl_hh_content ul\");\n      allUl.forEach((ul, i) => {\n        const ulTitle = ul.previousElementSibling;\nif (ulTitle) {\n        ulTitle.classList.add(\"tmpl_hh_content_title\");\n        if (i === 0) {\n          ul.previousElementSibling.classList.add(\"tmpl_hh_content_title--first\");\n        }\n}\n      });\n    };\n    const swiper_min = \"\";\n    const effectFade_min = \"\";\n    function isObject$1(obj) {\n      return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n    }\n    function extend$1(target = {}, src = {}) {\n      Object.keys(src).forEach((key) => {\n        if (typeof target[key] === \"undefined\")\n          target[key] = src[key];\n        else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n          extend$1(target[key], src[key]);\n        }\n      });\n    }\n    const ssrDocument = {\n      body: {},\n      addEventListener() {\n      },\n      removeEventListener() {\n      },\n      activeElement: {\n        blur() {\n        },\n        nodeName: \"\"\n      },\n      querySelector() {\n        return null;\n      },\n      querySelectorAll() {\n        return [];\n      },\n      getElementById() {\n        return null;\n      },\n      createEvent() {\n        return {\n          initEvent() {\n          }\n        };\n      },\n      createElement() {\n        return {\n          children: [],\n          childNodes: [],\n          style: {},\n          setAttribute() {\n          },\n          getElementsByTagName() {\n            return [];\n          }\n        };\n      },\n      createElementNS() {\n        return {};\n      },\n      importNode() {\n        return null;\n      },\n      location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n      }\n    };\n    function getDocument() {\n      const doc = typeof document !== \"undefined\" ? document : {};\n      extend$1(doc, ssrDocument);\n      return doc;\n    }\n    const ssrWindow = {\n      document: ssrDocument,\n      navigator: {\n        userAgent: \"\"\n      },\n      location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n      },\n      history: {\n        replaceState() {\n        },\n        pushState() {\n        },\n        go() {\n        },\n        back() {\n        }\n      },\n      CustomEvent: function CustomEvent() {\n        return this;\n      },\n      addEventListener() {\n      },\n      removeEventListener() {\n      },\n      getComputedStyle() {\n        return {\n          getPropertyValue() {\n            return \"\";\n          }\n        };\n      },\n      Image() {\n      },\n      Date() {\n      },\n      screen: {},\n      setTimeout() {\n      },\n      clearTimeout() {\n      },\n      matchMedia() {\n        return {};\n      },\n      requestAnimationFrame(callback) {\n        if (typeof setTimeout === \"undefined\") {\n          callback();\n          return null;\n        }\n        return setTimeout(callback, 0);\n      },\n      cancelAnimationFrame(id) {\n        if (typeof setTimeout === \"undefined\") {\n          return;\n        }\n        clearTimeout(id);\n      }\n    };\n    function getWindow() {\n      const win = typeof window !== \"undefined\" ? window : {};\n      extend$1(win, ssrWindow);\n      return win;\n    }\n    function deleteProps(obj) {\n      const object = obj;\n      Object.keys(object).forEach((key) => {\n        try {\n          object[key] = null;\n        } catch (e) {\n        }\n        try {\n          delete object[key];\n        } catch (e) {\n        }\n      });\n    }\n    function nextTick(callback, delay = 0) {\n      return setTimeout(callback, delay);\n    }\n    function now() {\n      return Date.now();\n    }\n    function getComputedStyle$1(el) {\n      const window2 = getWindow();\n      let style;\n      if (window2.getComputedStyle) {\n        style = window2.getComputedStyle(el, null);\n      }\n      if (!style && el.currentStyle) {\n        style = el.currentStyle;\n      }\n      if (!style) {\n        style = el.style;\n      }\n      return style;\n    }\n    function getTranslate(el, axis = \"x\") {\n      const window2 = getWindow();\n      let matrix;\n      let curTransform;\n      let transformMatrix;\n      const curStyle = getComputedStyle$1(el, null);\n      if (window2.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(\",\").length > 6) {\n          curTransform = curTransform.split(\", \").map((a) => a.replace(\",\", \".\")).join(\", \");\n        }\n        transformMatrix = new window2.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n      } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n        matrix = transformMatrix.toString().split(\",\");\n      }\n      if (axis === \"x\") {\n        if (window2.WebKitCSSMatrix)\n          curTransform = transformMatrix.m41;\n        else if (matrix.length === 16)\n          curTransform = parseFloat(matrix[12]);\n        else\n          curTransform = parseFloat(matrix[4]);\n      }\n      if (axis === \"y\") {\n        if (window2.WebKitCSSMatrix)\n          curTransform = transformMatrix.m42;\n        else if (matrix.length === 16)\n          curTransform = parseFloat(matrix[13]);\n        else\n          curTransform = parseFloat(matrix[5]);\n      }\n      return curTransform || 0;\n    }\n    function isObject(o) {\n      return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n    }\n    function isNode(node) {\n      if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") {\n        return node instanceof HTMLElement;\n      }\n      return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend(...args) {\n      const to = Object(args[0]);\n      const noExtend = [\"__proto__\", \"constructor\", \"prototype\"];\n      for (let i = 1; i < args.length; i += 1) {\n        const nextSource = args[i];\n        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {\n          const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n            const nextKey = keysArray[nextIndex];\n            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n            if (desc !== void 0 && desc.enumerable) {\n              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                to[nextKey] = {};\n                if (nextSource[nextKey].__swiper__) {\n                  to[nextKey] = nextSource[nextKey];\n                } else {\n                  extend(to[nextKey], nextSource[nextKey]);\n                }\n              } else {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n      }\n      return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n      el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll({\n      swiper,\n      targetPosition,\n      side\n    }) {\n      const window2 = getWindow();\n      const startPosition = -swiper.translate;\n      let startTime = null;\n      let time;\n      const duration = swiper.params.speed;\n      swiper.wrapperEl.style.scrollSnapType = \"none\";\n      window2.cancelAnimationFrame(swiper.cssModeFrameID);\n      const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n      const isOutOfBound = (current, target) => {\n        return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n      };\n      const animate = () => {\n        time = (/* @__PURE__ */ new Date()).getTime();\n        if (startTime === null) {\n          startTime = time;\n        }\n        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n          swiper.wrapperEl.style.overflow = \"hidden\";\n          swiper.wrapperEl.style.scrollSnapType = \"\";\n          setTimeout(() => {\n            swiper.wrapperEl.style.overflow = \"\";\n            swiper.wrapperEl.scrollTo({\n              [side]: currentPosition\n            });\n          });\n          window2.cancelAnimationFrame(swiper.cssModeFrameID);\n          return;\n        }\n        swiper.cssModeFrameID = window2.requestAnimationFrame(animate);\n      };\n      animate();\n    }\n    function getSlideTransformEl(slideEl) {\n      return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowEl && slideEl.shadowEl.querySelector(\".swiper-slide-transform\") || slideEl;\n    }\n    function findElementsInElements(elements = [], selector = \"\") {\n      const found = [];\n      elements.forEach((el) => {\n        found.push(...el.querySelectorAll(selector));\n      });\n      return found;\n    }\n    function elementChildren(element, selector = \"\") {\n      return [...element.children].filter((el) => el.matches(selector));\n    }\n    function createElement(tag, classes2 = []) {\n      const el = document.createElement(tag);\n      el.classList.add(...Array.isArray(classes2) ? classes2 : [classes2]);\n      return el;\n    }\n    function elementOffset(el) {\n      const window2 = getWindow();\n      const document2 = getDocument();\n      const box = el.getBoundingClientRect();\n      const body = document2.body;\n      const clientTop = el.clientTop || body.clientTop || 0;\n      const clientLeft = el.clientLeft || body.clientLeft || 0;\n      const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;\n      const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;\n      return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n      };\n    }\n    function elementPrevAll(el, selector) {\n      const prevEls = [];\n      while (el.previousElementSibling) {\n        const prev = el.previousElementSibling;\n        if (selector) {\n          if (prev.matches(selector))\n            prevEls.push(prev);\n        } else\n          prevEls.push(prev);\n        el = prev;\n      }\n      return prevEls;\n    }\n    function elementNextAll(el, selector) {\n      const nextEls = [];\n      while (el.nextElementSibling) {\n        const next = el.nextElementSibling;\n        if (selector) {\n          if (next.matches(selector))\n            nextEls.push(next);\n        } else\n          nextEls.push(next);\n        el = next;\n      }\n      return nextEls;\n    }\n    function elementStyle(el, prop) {\n      const window2 = getWindow();\n      return window2.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n      let child = el;\n      let i;\n      if (child) {\n        i = 0;\n        while ((child = child.previousSibling) !== null) {\n          if (child.nodeType === 1)\n            i += 1;\n        }\n        return i;\n      }\n      return void 0;\n    }\n    function elementParents(el, selector) {\n      const parents = [];\n      let parent = el.parentElement;\n      while (parent) {\n        if (selector) {\n          if (parent.matches(selector))\n            parents.push(parent);\n        } else {\n          parents.push(parent);\n        }\n        parent = parent.parentElement;\n      }\n      return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n      function fireCallBack(e) {\n        if (e.target !== el)\n          return;\n        callback.call(el, e);\n        el.removeEventListener(\"transitionend\", fireCallBack);\n      }\n      if (callback) {\n        el.addEventListener(\"transitionend\", fireCallBack);\n      }\n    }\n    function elementOuterSize(el, size, includeMargins) {\n      const window2 = getWindow();\n      if (includeMargins) {\n        return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n      }\n      return el.offsetWidth;\n    }\n    let support;\n    function calcSupport() {\n      const window2 = getWindow();\n      const document2 = getDocument();\n      return {\n        smoothScroll: document2.documentElement && \"scrollBehavior\" in document2.documentElement.style,\n        touch: !!(\"ontouchstart\" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)\n      };\n    }\n    function getSupport() {\n      if (!support) {\n        support = calcSupport();\n      }\n      return support;\n    }\n    let deviceCached;\n    function calcDevice({\n      userAgent\n    } = {}) {\n      const support2 = getSupport();\n      const window2 = getWindow();\n      const platform = window2.navigator.platform;\n      const ua = userAgent || window2.navigator.userAgent;\n      const device = {\n        ios: false,\n        android: false\n      };\n      const screenWidth = window2.screen.width;\n      const screenHeight = window2.screen.height;\n      const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n      let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n      const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n      const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n      const windows = platform === \"Win32\";\n      let macos = platform === \"MacIntel\";\n      const iPadScreens = [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"];\n      if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad)\n          ipad = [0, 1, \"13_0_0\"];\n        macos = false;\n      }\n      if (android && !windows) {\n        device.os = \"android\";\n        device.android = true;\n      }\n      if (ipad || iphone || ipod) {\n        device.os = \"ios\";\n        device.ios = true;\n      }\n      return device;\n    }\n    function getDevice(overrides = {}) {\n      if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n      }\n      return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n      const window2 = getWindow();\n      let needPerspectiveFix = false;\n      function isSafari() {\n        const ua = window2.navigator.userAgent.toLowerCase();\n        return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n      }\n      if (isSafari()) {\n        const ua = String(window2.navigator.userAgent);\n        if (ua.includes(\"Version/\")) {\n          const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num) => Number(num));\n          needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n      }\n      return {\n        isSafari: needPerspectiveFix || isSafari(),\n        needPerspectiveFix,\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)\n      };\n    }\n    function getBrowser() {\n      if (!browser) {\n        browser = calcBrowser();\n      }\n      return browser;\n    }\n    function Resize({\n      swiper,\n      on,\n      emit\n    }) {\n      const window2 = getWindow();\n      let observer = null;\n      let animationFrame = null;\n      const resizeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized)\n          return;\n        emit(\"beforeResize\");\n        emit(\"resize\");\n      };\n      const createObserver = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized)\n          return;\n        observer = new ResizeObserver((entries) => {\n          animationFrame = window2.requestAnimationFrame(() => {\n            const {\n              width,\n              height\n            } = swiper;\n            let newWidth = width;\n            let newHeight = height;\n            entries.forEach(({\n              contentBoxSize,\n              contentRect,\n              target\n            }) => {\n              if (target && target !== swiper.el)\n                return;\n              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n            });\n            if (newWidth !== width || newHeight !== height) {\n              resizeHandler();\n            }\n          });\n        });\n        observer.observe(swiper.el);\n      };\n      const removeObserver = () => {\n        if (animationFrame) {\n          window2.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n          observer.unobserve(swiper.el);\n          observer = null;\n        }\n      };\n      const orientationChangeHandler = () => {\n        if (!swiper || swiper.destroyed || !swiper.initialized)\n          return;\n        emit(\"orientationchange\");\n      };\n      on(\"init\", () => {\n        if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== \"undefined\") {\n          createObserver();\n          return;\n        }\n        window2.addEventListener(\"resize\", resizeHandler);\n        window2.addEventListener(\"orientationchange\", orientationChangeHandler);\n      });\n      on(\"destroy\", () => {\n        removeObserver();\n        window2.removeEventListener(\"resize\", resizeHandler);\n        window2.removeEventListener(\"orientationchange\", orientationChangeHandler);\n      });\n    }\n    function Observer({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const observers = [];\n      const window2 = getWindow();\n      const attach = (target, options = {}) => {\n        const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;\n        const observer = new ObserverFunc((mutations) => {\n          if (swiper.__preventObserver__)\n            return;\n          if (mutations.length === 1) {\n            emit(\"observerUpdate\", mutations[0]);\n            return;\n          }\n          const observerUpdate = function observerUpdate2() {\n            emit(\"observerUpdate\", mutations[0]);\n          };\n          if (window2.requestAnimationFrame) {\n            window2.requestAnimationFrame(observerUpdate);\n          } else {\n            window2.setTimeout(observerUpdate, 0);\n          }\n        });\n        observer.observe(target, {\n          attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n          childList: typeof options.childList === \"undefined\" ? true : options.childList,\n          characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n        });\n        observers.push(observer);\n      };\n      const init = () => {\n        if (!swiper.params.observer)\n          return;\n        if (swiper.params.observeParents) {\n          const containerParents = elementParents(swiper.el);\n          for (let i = 0; i < containerParents.length; i += 1) {\n            attach(containerParents[i]);\n          }\n        }\n        attach(swiper.el, {\n          childList: swiper.params.observeSlideChildren\n        });\n        attach(swiper.wrapperEl, {\n          attributes: false\n        });\n      };\n      const destroy = () => {\n        observers.forEach((observer) => {\n          observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n      };\n      extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n      });\n      on(\"init\", init);\n      on(\"destroy\", destroy);\n    }\n    const eventsEmitter = {\n      on(events2, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (typeof handler !== \"function\")\n          return self;\n        const method = priority ? \"unshift\" : \"push\";\n        events2.split(\" \").forEach((event2) => {\n          if (!self.eventsListeners[event2])\n            self.eventsListeners[event2] = [];\n          self.eventsListeners[event2][method](handler);\n        });\n        return self;\n      },\n      once(events2, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (typeof handler !== \"function\")\n          return self;\n        function onceHandler(...args) {\n          self.off(events2, onceHandler);\n          if (onceHandler.__emitterProxy) {\n            delete onceHandler.__emitterProxy;\n          }\n          handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events2, onceHandler, priority);\n      },\n      onAny(handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (typeof handler !== \"function\")\n          return self;\n        const method = priority ? \"unshift\" : \"push\";\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n          self.eventsAnyListeners[method](handler);\n        }\n        return self;\n      },\n      offAny(handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (!self.eventsAnyListeners)\n          return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n          self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n      },\n      off(events2, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (!self.eventsListeners)\n          return self;\n        events2.split(\" \").forEach((event2) => {\n          if (typeof handler === \"undefined\") {\n            self.eventsListeners[event2] = [];\n          } else if (self.eventsListeners[event2]) {\n            self.eventsListeners[event2].forEach((eventHandler, index) => {\n              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                self.eventsListeners[event2].splice(index, 1);\n              }\n            });\n          }\n        });\n        return self;\n      },\n      emit(...args) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed)\n          return self;\n        if (!self.eventsListeners)\n          return self;\n        let events2;\n        let data;\n        let context;\n        if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n          events2 = args[0];\n          data = args.slice(1, args.length);\n          context = self;\n        } else {\n          events2 = args[0].events;\n          data = args[0].data;\n          context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events2) ? events2 : events2.split(\" \");\n        eventsArray.forEach((event2) => {\n          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n            self.eventsAnyListeners.forEach((eventHandler) => {\n              eventHandler.apply(context, [event2, ...data]);\n            });\n          }\n          if (self.eventsListeners && self.eventsListeners[event2]) {\n            self.eventsListeners[event2].forEach((eventHandler) => {\n              eventHandler.apply(context, data);\n            });\n          }\n        });\n        return self;\n      }\n    };\n    function updateSize() {\n      const swiper = this;\n      let width;\n      let height;\n      const el = swiper.el;\n      if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n        width = swiper.params.width;\n      } else {\n        width = el.clientWidth;\n      }\n      if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n        height = swiper.params.height;\n      } else {\n        height = el.clientHeight;\n      }\n      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n      }\n      width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n      height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n      if (Number.isNaN(width))\n        width = 0;\n      if (Number.isNaN(height))\n        height = 0;\n      Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height\n      });\n    }\n    function updateSlides() {\n      const swiper = this;\n      function getDirectionLabel(property) {\n        if (swiper.isHorizontal()) {\n          return property;\n        }\n        return {\n          \"width\": \"height\",\n          \"margin-top\": \"margin-left\",\n          \"margin-bottom \": \"margin-right\",\n          \"margin-left\": \"margin-top\",\n          \"margin-right\": \"margin-bottom\",\n          \"padding-left\": \"padding-top\",\n          \"padding-right\": \"padding-bottom\",\n          \"marginRight\": \"marginBottom\"\n        }[property];\n      }\n      function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n      }\n      const params = swiper.params;\n      const {\n        wrapperEl,\n        slidesEl,\n        size: swiperSize,\n        rtlTranslate: rtl,\n        wrongRTL\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n      const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n      let snapGrid = [];\n      const slidesGrid = [];\n      const slidesSizesGrid = [];\n      let offsetBefore = params.slidesOffsetBefore;\n      if (typeof offsetBefore === \"function\") {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n      }\n      let offsetAfter = params.slidesOffsetAfter;\n      if (typeof offsetAfter === \"function\") {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n      }\n      const previousSnapGridLength = swiper.snapGrid.length;\n      const previousSlidesGridLength = swiper.slidesGrid.length;\n      let spaceBetween = params.spaceBetween;\n      let slidePosition = -offsetBefore;\n      let prevSlideSize = 0;\n      let index = 0;\n      if (typeof swiperSize === \"undefined\") {\n        return;\n      }\n      if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n      }\n      swiper.virtualSize = -spaceBetween;\n      slides.forEach((slideEl) => {\n        if (rtl) {\n          slideEl.style.marginLeft = \"\";\n        } else {\n          slideEl.style.marginRight = \"\";\n        }\n        slideEl.style.marginBottom = \"\";\n        slideEl.style.marginTop = \"\";\n      });\n      if (params.centeredSlides && params.cssMode) {\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n      }\n      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n      if (gridEnabled) {\n        swiper.grid.initSlides(slidesLength);\n      }\n      let slideSize;\n      const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {\n        return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n      }).length > 0;\n      for (let i = 0; i < slidesLength; i += 1) {\n        slideSize = 0;\n        let slide2;\n        if (slides[i])\n          slide2 = slides[i];\n        if (gridEnabled) {\n          swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);\n        }\n        if (slides[i] && elementStyle(slide2, \"display\") === \"none\")\n          continue;\n        if (params.slidesPerView === \"auto\") {\n          if (shouldResetSlideSize) {\n            slides[i].style[getDirectionLabel(\"width\")] = ``;\n          }\n          const slideStyles = getComputedStyle(slide2);\n          const currentTransform = slide2.style.transform;\n          const currentWebKitTransform = slide2.style.webkitTransform;\n          if (currentTransform) {\n            slide2.style.transform = \"none\";\n          }\n          if (currentWebKitTransform) {\n            slide2.style.webkitTransform = \"none\";\n          }\n          if (params.roundLengths) {\n            slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, \"width\", true) : elementOuterSize(slide2, \"height\", true);\n          } else {\n            const width = getDirectionPropertyValue(slideStyles, \"width\");\n            const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n            const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n            const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n            const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n            const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n            if (boxSizing && boxSizing === \"border-box\") {\n              slideSize = width + marginLeft + marginRight;\n            } else {\n              const {\n                clientWidth,\n                offsetWidth\n              } = slide2;\n              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n            }\n          }\n          if (currentTransform) {\n            slide2.style.transform = currentTransform;\n          }\n          if (currentWebKitTransform) {\n            slide2.style.webkitTransform = currentWebKitTransform;\n          }\n          if (params.roundLengths)\n            slideSize = Math.floor(slideSize);\n        } else {\n          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n          if (params.roundLengths)\n            slideSize = Math.floor(slideSize);\n          if (slides[i]) {\n            slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n          }\n        }\n        if (slides[i]) {\n          slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n          if (prevSlideSize === 0 && i !== 0)\n            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (i === 0)\n            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n          if (Math.abs(slidePosition) < 1 / 1e3)\n            slidePosition = 0;\n          if (params.roundLengths)\n            slidePosition = Math.floor(slidePosition);\n          if (index % params.slidesPerGroup === 0)\n            snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n        } else {\n          if (params.roundLengths)\n            slidePosition = Math.floor(slidePosition);\n          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)\n            snapGrid.push(slidePosition);\n          slidesGrid.push(slidePosition);\n          slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n      }\n      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n      if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n        wrapperEl.style.width = `${swiper.virtualSize + params.spaceBetween}px`;\n      }\n      if (params.setWrapperSize) {\n        wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + params.spaceBetween}px`;\n      }\n      if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n      }\n      if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (params.roundLengths)\n            slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n            newSlidesGrid.push(slidesGridItem);\n          }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n          snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n      }\n      if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n          const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n          const groupSize = size * params.slidesPerGroup;\n          for (let i = 0; i < groups; i += 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n          }\n        }\n        for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n          if (params.slidesPerGroup === 1) {\n            snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n          }\n          slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n          swiper.virtualSize += size;\n        }\n      }\n      if (snapGrid.length === 0)\n        snapGrid = [0];\n      if (params.spaceBetween !== 0) {\n        const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n        slides.filter((_, slideIndex) => {\n          if (!params.cssMode || params.loop)\n            return true;\n          if (slideIndex === slides.length - 1) {\n            return false;\n          }\n          return true;\n        }).forEach((slideEl) => {\n          slideEl.style[key] = `${spaceBetween}px`;\n        });\n      }\n      if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue) => {\n          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n        });\n        allSlidesSize -= params.spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map((snap) => {\n          if (snap < 0)\n            return -offsetBefore;\n          if (snap > maxSnap)\n            return maxSnap + offsetAfter;\n          return snap;\n        });\n      }\n      if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue) => {\n          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n        });\n        allSlidesSize -= params.spaceBetween;\n        if (allSlidesSize < swiperSize) {\n          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n          snapGrid.forEach((snap, snapIndex) => {\n            snapGrid[snapIndex] = snap - allSlidesOffset;\n          });\n          slidesGrid.forEach((snap, snapIndex) => {\n            slidesGrid[snapIndex] = snap + allSlidesOffset;\n          });\n        }\n      }\n      Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid\n      });\n      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n        setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n      }\n      if (slidesLength !== previousSlidesLength) {\n        swiper.emit(\"slidesLengthChange\");\n      }\n      if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow)\n          swiper.checkOverflow();\n        swiper.emit(\"snapGridLengthChange\");\n      }\n      if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit(\"slidesGridLengthChange\");\n      }\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n          if (!hasClassBackfaceClassAdded)\n            swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n          swiper.el.classList.remove(backFaceHiddenClass);\n        }\n      }\n    }\n    function updateAutoHeight(speed) {\n      const swiper = this;\n      const activeSlides = [];\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let newHeight = 0;\n      let i;\n      if (typeof speed === \"number\") {\n        swiper.setTransition(speed);\n      } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n      }\n      const getSlideByIndex = (index) => {\n        if (isVirtual) {\n          return swiper.slides.filter((el) => parseInt(el.getAttribute(\"data-swiper-slide-index\"), 10) === index)[0];\n        }\n        return swiper.slides[index];\n      };\n      if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n          (swiper.visibleSlides || []).forEach((slide2) => {\n            activeSlides.push(slide2);\n          });\n        } else {\n          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n            const index = swiper.activeIndex + i;\n            if (index > swiper.slides.length && !isVirtual)\n              break;\n            activeSlides.push(getSlideByIndex(index));\n          }\n        }\n      } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n      }\n      for (i = 0; i < activeSlides.length; i += 1) {\n        if (typeof activeSlides[i] !== \"undefined\") {\n          const height = activeSlides[i].offsetHeight;\n          newHeight = height > newHeight ? height : newHeight;\n        }\n      }\n      if (newHeight || newHeight === 0)\n        swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n    function updateSlidesOffset() {\n      const swiper = this;\n      const slides = swiper.slides;\n      const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n      for (let i = 0; i < slides.length; i += 1) {\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset;\n      }\n    }\n    function updateSlidesProgress(translate2 = this && this.translate || 0) {\n      const swiper = this;\n      const params = swiper.params;\n      const {\n        slides,\n        rtlTranslate: rtl,\n        snapGrid\n      } = swiper;\n      if (slides.length === 0)\n        return;\n      if (typeof slides[0].swiperSlideOffset === \"undefined\")\n        swiper.updateSlidesOffset();\n      let offsetCenter = -translate2;\n      if (rtl)\n        offsetCenter = translate2;\n      slides.forEach((slideEl) => {\n        slideEl.classList.remove(params.slideVisibleClass);\n      });\n      swiper.visibleSlidesIndexes = [];\n      swiper.visibleSlides = [];\n      for (let i = 0; i < slides.length; i += 1) {\n        const slide2 = slides[i];\n        let slideOffset = slide2.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n          slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);\n        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n          swiper.visibleSlides.push(slide2);\n          swiper.visibleSlidesIndexes.push(i);\n          slides[i].classList.add(params.slideVisibleClass);\n        }\n        slide2.progress = rtl ? -slideProgress : slideProgress;\n        slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n      }\n    }\n    function updateProgress(translate2) {\n      const swiper = this;\n      if (typeof translate2 === \"undefined\") {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;\n      }\n      const params = swiper.params;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      let {\n        progress,\n        isBeginning,\n        isEnd,\n        progressLoop\n      } = swiper;\n      const wasBeginning = isBeginning;\n      const wasEnd = isEnd;\n      if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n      } else {\n        progress = (translate2 - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded)\n          progress = 0;\n        if (isEndRounded)\n          progress = 1;\n      }\n      if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el) => el.getAttribute(\"data-swiper-slide-index\") === \"0\")[0]);\n        const lastSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el) => el.getAttribute(\"data-swiper-slide-index\") * 1 === swiper.slides.length - 1)[0]);\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate2);\n        if (translateAbs >= firstSlideTranslate) {\n          progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n          progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1)\n          progressLoop -= 1;\n      }\n      Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd\n      });\n      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)\n        swiper.updateSlidesProgress(translate2);\n      if (isBeginning && !wasBeginning) {\n        swiper.emit(\"reachBeginning toEdge\");\n      }\n      if (isEnd && !wasEnd) {\n        swiper.emit(\"reachEnd toEdge\");\n      }\n      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit(\"fromEdge\");\n      }\n      swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n      const swiper = this;\n      const {\n        slides,\n        params,\n        slidesEl,\n        activeIndex\n      } = swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      const getFilteredSlide = (selector) => {\n        return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n      };\n      slides.forEach((slideEl) => {\n        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n      });\n      let activeSlide;\n      if (isVirtual) {\n        if (params.loop) {\n          let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n          if (slideIndex < 0)\n            slideIndex = swiper.virtual.slides.length + slideIndex;\n          if (slideIndex >= swiper.virtual.slides.length)\n            slideIndex -= swiper.virtual.slides.length;\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n        } else {\n          activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        }\n      } else {\n        activeSlide = slides[activeIndex];\n      }\n      if (activeSlide) {\n        activeSlide.classList.add(params.slideActiveClass);\n        let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !nextSlide) {\n          nextSlide = slides[0];\n        }\n        if (nextSlide) {\n          nextSlide.classList.add(params.slideNextClass);\n        }\n        let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n        if (params.loop && !prevSlide === 0) {\n          prevSlide = slides[slides.length - 1];\n        }\n        if (prevSlide) {\n          prevSlide.classList.add(params.slidePrevClass);\n        }\n      }\n      swiper.emitSlidesClasses();\n    }\n    function getActiveIndexByTranslate(swiper) {\n      const {\n        slidesGrid,\n        params\n      } = swiper;\n      const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      let activeIndex;\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        if (typeof slidesGrid[i + 1] !== \"undefined\") {\n          if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n            activeIndex = i;\n          } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {\n            activeIndex = i + 1;\n          }\n        } else if (translate2 >= slidesGrid[i]) {\n          activeIndex = i;\n        }\n      }\n      if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === \"undefined\")\n          activeIndex = 0;\n      }\n      return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n      const swiper = this;\n      const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      const {\n        snapGrid,\n        params,\n        activeIndex: previousIndex,\n        realIndex: previousRealIndex,\n        snapIndex: previousSnapIndex\n      } = swiper;\n      let activeIndex = newActiveIndex;\n      let snapIndex;\n      const getVirtualRealIndex = (aIndex) => {\n        let realIndex2 = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex2 < 0) {\n          realIndex2 = swiper.virtual.slides.length + realIndex2;\n        }\n        if (realIndex2 >= swiper.virtual.slides.length) {\n          realIndex2 -= swiper.virtual.slides.length;\n        }\n        return realIndex2;\n      };\n      if (typeof activeIndex === \"undefined\") {\n        activeIndex = getActiveIndexByTranslate(swiper);\n      }\n      if (snapGrid.indexOf(translate2) >= 0) {\n        snapIndex = snapGrid.indexOf(translate2);\n      } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n      }\n      if (snapIndex >= snapGrid.length)\n        snapIndex = snapGrid.length - 1;\n      if (activeIndex === previousIndex) {\n        if (snapIndex !== previousSnapIndex) {\n          swiper.snapIndex = snapIndex;\n          swiper.emit(\"snapIndexChange\");\n        }\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.realIndex = getVirtualRealIndex(activeIndex);\n        }\n        return;\n      }\n      let realIndex;\n      if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n      } else if (swiper.slides[activeIndex]) {\n        realIndex = parseInt(swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") || activeIndex, 10);\n      } else {\n        realIndex = activeIndex;\n      }\n      Object.assign(swiper, {\n        snapIndex,\n        realIndex,\n        previousIndex,\n        activeIndex\n      });\n      swiper.emit(\"activeIndexChange\");\n      swiper.emit(\"snapIndexChange\");\n      if (previousRealIndex !== realIndex) {\n        swiper.emit(\"realIndexChange\");\n      }\n      if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        swiper.emit(\"slideChange\");\n      }\n    }\n    function updateClickedSlide(e) {\n      const swiper = this;\n      const params = swiper.params;\n      const slide2 = e.closest(`.${params.slideClass}, swiper-slide`);\n      let slideFound = false;\n      let slideIndex;\n      if (slide2) {\n        for (let i = 0; i < swiper.slides.length; i += 1) {\n          if (swiper.slides[i] === slide2) {\n            slideFound = true;\n            slideIndex = i;\n            break;\n          }\n        }\n      }\n      if (slide2 && slideFound) {\n        swiper.clickedSlide = slide2;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.clickedIndex = parseInt(slide2.getAttribute(\"data-swiper-slide-index\"), 10);\n        } else {\n          swiper.clickedIndex = slideIndex;\n        }\n      } else {\n        swiper.clickedSlide = void 0;\n        swiper.clickedIndex = void 0;\n        return;\n      }\n      if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n      }\n    }\n    const update = {\n      updateSize,\n      updateSlides,\n      updateAutoHeight,\n      updateSlidesOffset,\n      updateSlidesProgress,\n      updateProgress,\n      updateSlidesClasses,\n      updateActiveIndex,\n      updateClickedSlide\n    };\n    function getSwiperTranslate(axis = this.isHorizontal() ? \"x\" : \"y\") {\n      const swiper = this;\n      const {\n        params,\n        rtlTranslate: rtl,\n        translate: translate2,\n        wrapperEl\n      } = swiper;\n      if (params.virtualTranslate) {\n        return rtl ? -translate2 : translate2;\n      }\n      if (params.cssMode) {\n        return translate2;\n      }\n      let currentTranslate = getTranslate(wrapperEl, axis);\n      if (rtl)\n        currentTranslate = -currentTranslate;\n      return currentTranslate || 0;\n    }\n    function setTranslate(translate2, byController) {\n      const swiper = this;\n      const {\n        rtlTranslate: rtl,\n        params,\n        wrapperEl,\n        progress\n      } = swiper;\n      let x = 0;\n      let y = 0;\n      const z = 0;\n      if (swiper.isHorizontal()) {\n        x = rtl ? -translate2 : translate2;\n      } else {\n        y = translate2;\n      }\n      if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n      }\n      if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n      } else if (!params.virtualTranslate) {\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n      }\n      swiper.previousTranslate = swiper.translate;\n      swiper.translate = swiper.isHorizontal() ? x : y;\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== progress) {\n        swiper.updateProgress(translate2);\n      }\n      swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n      return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n      return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {\n      const swiper = this;\n      const {\n        params,\n        wrapperEl\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n      }\n      const minTranslate2 = swiper.minTranslate();\n      const maxTranslate2 = swiper.maxTranslate();\n      let newTranslate;\n      if (translateBounds && translate2 > minTranslate2)\n        newTranslate = minTranslate2;\n      else if (translateBounds && translate2 < maxTranslate2)\n        newTranslate = maxTranslate2;\n      else\n        newTranslate = translate2;\n      swiper.updateProgress(newTranslate);\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n          wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: -newTranslate,\n              side: isH ? \"left\" : \"top\"\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? \"left\" : \"top\"]: -newTranslate,\n            behavior: \"smooth\"\n          });\n        }\n        return true;\n      }\n      if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit(\"beforeTransitionStart\", speed, internal);\n          swiper.emit(\"transitionEnd\");\n        }\n      } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n          swiper.emit(\"beforeTransitionStart\", speed, internal);\n          swiper.emit(\"transitionStart\");\n        }\n        if (!swiper.animating) {\n          swiper.animating = true;\n          if (!swiper.onTranslateToWrapperTransitionEnd) {\n            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {\n              if (!swiper || swiper.destroyed)\n                return;\n              if (e.target !== this)\n                return;\n              swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n              swiper.onTranslateToWrapperTransitionEnd = null;\n              delete swiper.onTranslateToWrapperTransitionEnd;\n              if (runCallbacks) {\n                swiper.emit(\"transitionEnd\");\n              }\n            };\n          }\n          swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n        }\n      }\n      return true;\n    }\n    const translate = {\n      getTranslate: getSwiperTranslate,\n      setTranslate,\n      minTranslate,\n      maxTranslate,\n      translateTo\n    };\n    function setTransition(duration, byController) {\n      const swiper = this;\n      if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n      }\n      swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step\n    }) {\n      const {\n        activeIndex,\n        previousIndex\n      } = swiper;\n      let dir = direction;\n      if (!dir) {\n        if (activeIndex > previousIndex)\n          dir = \"next\";\n        else if (activeIndex < previousIndex)\n          dir = \"prev\";\n        else\n          dir = \"reset\";\n      }\n      swiper.emit(`transition${step}`);\n      if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === \"reset\") {\n          swiper.emit(`slideResetTransition${step}`);\n          return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === \"next\") {\n          swiper.emit(`slideNextTransition${step}`);\n        } else {\n          swiper.emit(`slidePrevTransition${step}`);\n        }\n      }\n    }\n    function transitionStart(runCallbacks = true, direction) {\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      if (params.cssMode)\n        return;\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"Start\"\n      });\n    }\n    function transitionEnd(runCallbacks = true, direction) {\n      const swiper = this;\n      const {\n        params\n      } = swiper;\n      swiper.animating = false;\n      if (params.cssMode)\n        return;\n      swiper.setTransition(0);\n      transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"End\"\n      });\n    }\n    const transition = {\n      setTransition,\n      transitionStart,\n      transitionEnd\n    };\n    function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n      if (typeof index === \"string\") {\n        index = parseInt(index, 10);\n      }\n      const swiper = this;\n      let slideIndex = index;\n      if (slideIndex < 0)\n        slideIndex = 0;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        previousIndex,\n        activeIndex,\n        rtlTranslate: rtl,\n        wrapperEl,\n        enabled\n      } = swiper;\n      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n        return false;\n      }\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n      if (snapIndex >= snapGrid.length)\n        snapIndex = snapGrid.length - 1;\n      const translate2 = -snapGrid[snapIndex];\n      if (params.normalizeSlideIndex) {\n        for (let i = 0; i < slidesGrid.length; i += 1) {\n          const normalizedTranslate = -Math.floor(translate2 * 100);\n          const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n          if (typeof slidesGrid[i + 1] !== \"undefined\") {\n            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n              slideIndex = i;\n            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n              slideIndex = i + 1;\n            }\n          } else if (normalizedTranslate >= normalizedGrid) {\n            slideIndex = i;\n          }\n        }\n      }\n      if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {\n          if ((activeIndex || 0) !== slideIndex) {\n            return false;\n          }\n        }\n      }\n      if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit(\"beforeSlideChangeStart\");\n      }\n      swiper.updateProgress(translate2);\n      let direction;\n      if (slideIndex > activeIndex)\n        direction = \"next\";\n      else if (slideIndex < activeIndex)\n        direction = \"prev\";\n      else\n        direction = \"reset\";\n      if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== \"slide\") {\n          swiper.setTranslate(translate2);\n        }\n        if (direction !== \"reset\") {\n          swiper.transitionStart(runCallbacks, direction);\n          swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n      }\n      if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate2 : -translate2;\n        if (speed === 0) {\n          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n          if (isVirtual) {\n            swiper.wrapperEl.style.scrollSnapType = \"none\";\n            swiper._immediateVirtual = true;\n          }\n          if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n            swiper._cssModeVirtualInitialSet = true;\n            requestAnimationFrame(() => {\n              wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n            });\n          } else {\n            wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n          }\n          if (isVirtual) {\n            requestAnimationFrame(() => {\n              swiper.wrapperEl.style.scrollSnapType = \"\";\n              swiper._immediateVirtual = false;\n            });\n          }\n        } else {\n          if (!swiper.support.smoothScroll) {\n            animateCSSModeScroll({\n              swiper,\n              targetPosition: t,\n              side: isH ? \"left\" : \"top\"\n            });\n            return true;\n          }\n          wrapperEl.scrollTo({\n            [isH ? \"left\" : \"top\"]: t,\n            behavior: \"smooth\"\n          });\n        }\n        return true;\n      }\n      swiper.setTransition(speed);\n      swiper.setTranslate(translate2);\n      swiper.updateActiveIndex(slideIndex);\n      swiper.updateSlidesClasses();\n      swiper.emit(\"beforeTransitionStart\", speed, internal);\n      swiper.transitionStart(runCallbacks, direction);\n      if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n      } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {\n            if (!swiper || swiper.destroyed)\n              return;\n            if (e.target !== this)\n              return;\n            swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n            swiper.onSlideToWrapperTransitionEnd = null;\n            delete swiper.onSlideToWrapperTransitionEnd;\n            swiper.transitionEnd(runCallbacks, direction);\n          };\n        }\n        swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n      }\n      return true;\n    }\n    function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n      if (typeof index === \"string\") {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n      }\n      const swiper = this;\n      let newIndex = index;\n      if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n          newIndex = swiper.getSlideIndex(swiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === newIndex)[0]);\n        }\n      }\n      return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    function slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n      const swiper = this;\n      const {\n        enabled,\n        params,\n        animating\n      } = swiper;\n      if (!enabled)\n        return swiper;\n      let perGroup = params.slidesPerGroup;\n      if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n      }\n      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding)\n          return false;\n        swiper.loopFix({\n          direction: \"next\"\n        });\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n    function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n      const swiper = this;\n      const {\n        params,\n        snapGrid,\n        slidesGrid,\n        rtlTranslate,\n        enabled,\n        animating\n      } = swiper;\n      if (!enabled)\n        return swiper;\n      const isVirtual = swiper.virtual && params.virtual.enabled;\n      if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding)\n          return false;\n        swiper.loopFix({\n          direction: \"prev\"\n        });\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n      }\n      const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;\n      function normalize(val) {\n        if (val < 0)\n          return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n      }\n      const normalizedTranslate = normalize(translate2);\n      const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n      if (typeof prevSnap === \"undefined\" && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex) => {\n          if (normalizedTranslate >= snap) {\n            prevSnapIndex = snapIndex;\n          }\n        });\n        if (typeof prevSnapIndex !== \"undefined\") {\n          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n      }\n      let prevIndex = 0;\n      if (typeof prevSnap !== \"undefined\") {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0)\n          prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n          prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n          prevIndex = Math.max(prevIndex, 0);\n        }\n      }\n      if (params.rewind && swiper.isBeginning) {\n        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n      }\n      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    function slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n      const swiper = this;\n      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {\n      const swiper = this;\n      let index = swiper.activeIndex;\n      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n      const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n      if (translate2 >= swiper.snapGrid[snapIndex]) {\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {\n          index += swiper.params.slidesPerGroup;\n        }\n      } else {\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {\n          index -= swiper.params.slidesPerGroup;\n        }\n      }\n      index = Math.max(index, 0);\n      index = Math.min(index, swiper.slidesGrid.length - 1);\n      return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n      let slideToIndex = swiper.clickedIndex;\n      let realIndex;\n      const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n      if (params.loop) {\n        if (swiper.animating)\n          return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (params.centeredSlides) {\n          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n            nextTick(() => {\n              swiper.slideTo(slideToIndex);\n            });\n          } else {\n            swiper.slideTo(slideToIndex);\n          }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n    const slide = {\n      slideTo,\n      slideToLoop,\n      slideNext,\n      slidePrev,\n      slideReset,\n      slideToClosest,\n      slideToClickedSlide\n    };\n    function loopCreate(slideRealIndex) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n        return;\n      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      slides.forEach((el, index) => {\n        el.setAttribute(\"data-swiper-slide-index\", index);\n      });\n      swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? void 0 : \"next\"\n      });\n    }\n    function loopFix({\n      slideRealIndex,\n      slideTo: slideTo2 = true,\n      direction,\n      setTranslate: setTranslate2,\n      activeSlideIndex,\n      byController,\n      byMousewheel\n    } = {}) {\n      const swiper = this;\n      if (!swiper.params.loop)\n        return;\n      swiper.emit(\"beforeLoopFix\");\n      const {\n        slides,\n        allowSlidePrev,\n        allowSlideNext,\n        slidesEl,\n        params\n      } = swiper;\n      swiper.allowSlidePrev = true;\n      swiper.allowSlideNext = true;\n      if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo2) {\n          if (!params.centeredSlides && swiper.snapIndex === 0) {\n            swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n          } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n            swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n          } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n            swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n          }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n        return;\n      }\n      const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n      let loopedSlides = params.loopedSlides || slidesPerView;\n      if (loopedSlides % params.slidesPerGroup !== 0) {\n        loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n      }\n      swiper.loopedSlides = loopedSlides;\n      const prependSlidesIndexes = [];\n      const appendSlidesIndexes = [];\n      let activeIndex = swiper.activeIndex;\n      if (typeof activeSlideIndex === \"undefined\") {\n        activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el) => el.classList.contains(\"swiper-slide-active\"))[0]);\n      } else {\n        activeIndex = activeSlideIndex;\n      }\n      const isNext = direction === \"next\" || !direction;\n      const isPrev = direction === \"prev\" || !direction;\n      let slidesPrepended = 0;\n      let slidesAppended = 0;\n      if (activeSlideIndex < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n        for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          prependSlidesIndexes.push(slides.length - index - 1);\n        }\n      } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {\n        slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n        for (let i = 0; i < slidesAppended; i += 1) {\n          const index = i - Math.floor(i / slides.length) * slides.length;\n          appendSlidesIndexes.push(index);\n        }\n      }\n      if (isPrev) {\n        prependSlidesIndexes.forEach((index) => {\n          slidesEl.prepend(swiper.slides[index]);\n        });\n      }\n      if (isNext) {\n        appendSlidesIndexes.forEach((index) => {\n          slidesEl.append(swiper.slides[index]);\n        });\n      }\n      swiper.recalcSlides();\n      if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n      }\n      if (slideTo2) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n          if (typeof slideRealIndex === \"undefined\") {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n              if (setTranslate2) {\n                swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n              }\n            }\n          } else {\n            if (setTranslate2) {\n              swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n          }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n          if (typeof slideRealIndex === \"undefined\") {\n            const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n            const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n            const diff = newSlideTranslate - currentSlideTranslate;\n            if (byMousewheel) {\n              swiper.setTranslate(swiper.translate - diff);\n            } else {\n              swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n              if (setTranslate2) {\n                swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n              }\n            }\n          } else {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n          }\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n          slideRealIndex,\n          slideTo: false,\n          direction,\n          setTranslate: setTranslate2,\n          activeSlideIndex,\n          byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n          swiper.controller.control.forEach((c) => {\n            if (c.params.loop)\n              c.loopFix(loopParams);\n          });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n          swiper.controller.control.loopFix(loopParams);\n        }\n      }\n      swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n      const swiper = this;\n      const {\n        slides,\n        params,\n        slidesEl\n      } = swiper;\n      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)\n        return;\n      swiper.recalcSlides();\n      const newSlidesOrder = [];\n      slides.forEach((slideEl) => {\n        const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n      });\n      slides.forEach((slideEl) => {\n        slideEl.removeAttribute(\"data-swiper-slide-index\");\n      });\n      newSlidesOrder.forEach((slideEl) => {\n        slidesEl.append(slideEl);\n      });\n      swiper.recalcSlides();\n      swiper.slideTo(swiper.realIndex, 0);\n    }\n    const loop = {\n      loopCreate,\n      loopFix,\n      loopDestroy\n    };\n    function setGrabCursor(moving) {\n      const swiper = this;\n      if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)\n        return;\n      const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      el.style.cursor = \"move\";\n      el.style.cursor = moving ? \"grabbing\" : \"grab\";\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n    function unsetGrabCursor() {\n      const swiper = this;\n      if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n      }\n      if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n      }\n      swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n      if (swiper.isElement) {\n        requestAnimationFrame(() => {\n          swiper.__preventObserver__ = false;\n        });\n      }\n    }\n    const grabCursor = {\n      setGrabCursor,\n      unsetGrabCursor\n    };\n    function closestElement(selector, base = this) {\n      function __closestFrom(el) {\n        if (!el || el === getDocument() || el === getWindow())\n          return null;\n        if (el.assignedSlot)\n          el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n          return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n      }\n      return __closestFrom(base);\n    }\n    function onTouchStart(event2) {\n      const swiper = this;\n      const document2 = getDocument();\n      const window2 = getWindow();\n      const data = swiper.touchEventsData;\n      data.evCache.push(event2);\n      const {\n        params,\n        touches,\n        enabled\n      } = swiper;\n      if (!enabled)\n        return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\")\n        return;\n      if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n      }\n      if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n      }\n      let e = event2;\n      if (e.originalEvent)\n        e = e.originalEvent;\n      let targetEl = e.target;\n      if (params.touchEventsTarget === \"wrapper\") {\n        if (!swiper.wrapperEl.contains(targetEl))\n          return;\n      }\n      if (\"which\" in e && e.which === 3)\n        return;\n      if (\"button\" in e && e.button > 0)\n        return;\n      if (data.isTouched && data.isMoved)\n        return;\n      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n      const eventPath = event2.composedPath ? event2.composedPath() : event2.path;\n      if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n      }\n      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n      const isTargetShadow = !!(e.target && e.target.shadowRoot);\n      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n      }\n      if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler))\n          return;\n      }\n      touches.currentX = e.pageX;\n      touches.currentY = e.pageY;\n      const startX = touches.currentX;\n      const startY = touches.currentY;\n      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === \"prevent\") {\n          event2.preventDefault();\n        } else {\n          return;\n        }\n      }\n      Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: void 0,\n        startMoving: void 0\n      });\n      touches.startX = startX;\n      touches.startY = startY;\n      data.touchStartTime = now();\n      swiper.allowClick = true;\n      swiper.updateSize();\n      swiper.swipeDirection = void 0;\n      if (params.threshold > 0)\n        data.allowThresholdMove = false;\n      let preventDefault = true;\n      if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === \"SELECT\") {\n          data.isTouched = false;\n        }\n      }\n      if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {\n        document2.activeElement.blur();\n      }\n      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n      }\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n      }\n      swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event2) {\n      const document2 = getDocument();\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        enabled\n      } = swiper;\n      if (!enabled)\n        return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\")\n        return;\n      let e = event2;\n      if (e.originalEvent)\n        e = e.originalEvent;\n      if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n          swiper.emit(\"touchMoveOpposite\", e);\n        }\n        return;\n      }\n      const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0)\n        data.evCache[pointerIndex] = e;\n      const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n      const pageX = targetTouch.pageX;\n      const pageY = targetTouch.pageY;\n      if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n      }\n      if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n          swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n          Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            prevX: swiper.touches.currentX,\n            prevY: swiper.touches.currentY,\n            currentX: pageX,\n            currentY: pageY\n          });\n          data.touchStartTime = now();\n        }\n        return;\n      }\n      if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n            data.isTouched = false;\n            data.isMoved = false;\n            return;\n          }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n          return;\n        }\n      }\n      if (document2.activeElement) {\n        if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {\n          data.isMoved = true;\n          swiper.allowClick = false;\n          return;\n        }\n      }\n      if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchMove\", e);\n      }\n      if (e.targetTouches && e.targetTouches.length > 1)\n        return;\n      touches.currentX = pageX;\n      touches.currentY = pageY;\n      const diffX = touches.currentX - touches.startX;\n      const diffY = touches.currentY - touches.startY;\n      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)\n        return;\n      if (typeof data.isScrolling === \"undefined\") {\n        let touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n          data.isScrolling = false;\n        } else {\n          if (diffX * diffX + diffY * diffY >= 25) {\n            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n          }\n        }\n      }\n      if (data.isScrolling) {\n        swiper.emit(\"touchMoveOpposite\", e);\n      }\n      if (typeof data.startMoving === \"undefined\") {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n          data.startMoving = true;\n        }\n      }\n      if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n        data.isTouched = false;\n        return;\n      }\n      if (!data.startMoving) {\n        return;\n      }\n      swiper.allowClick = false;\n      if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n      }\n      if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n      }\n      let diff = swiper.isHorizontal() ? diffX : diffY;\n      let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n      if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n      }\n      touches.diff = diff;\n      diff *= params.touchRatio;\n      if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n      }\n      const prevTouchesDirection = swiper.touchesDirection;\n      swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n      swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n      const isLoop = swiper.params.loop && !params.cssMode;\n      if (!data.isMoved) {\n        if (isLoop) {\n          swiper.loopFix({\n            direction: swiper.swipeDirection\n          });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n          const evt = new window.CustomEvent(\"transitionend\", {\n            bubbles: true,\n            cancelable: true\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n          swiper.setGrabCursor(true);\n        }\n        swiper.emit(\"sliderFirstMove\", e);\n      }\n      let loopFixed;\n      if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n        swiper.loopFix({\n          direction: swiper.swipeDirection,\n          setTranslate: true\n        });\n        loopFixed = true;\n      }\n      swiper.emit(\"sliderMove\", e);\n      data.isMoved = true;\n      data.currentTranslate = diff + data.startTranslate;\n      let disableParentSwiper = true;\n      let resistanceRatio = params.resistanceRatio;\n      if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n      }\n      if (diff > 0) {\n        if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n          swiper.loopFix({\n            direction: \"prev\",\n            setTranslate: true,\n            activeSlideIndex: 0\n          });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n          }\n        }\n      } else if (diff < 0) {\n        if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n          swiper.loopFix({\n            direction: \"next\",\n            setTranslate: true,\n            activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n          });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n          disableParentSwiper = false;\n          if (params.resistance) {\n            data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n          }\n        }\n      }\n      if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n      }\n      if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n      }\n      if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n          if (!data.allowThresholdMove) {\n            data.allowThresholdMove = true;\n            touches.startX = touches.currentX;\n            touches.startY = touches.currentY;\n            data.currentTranslate = data.startTranslate;\n            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n            return;\n          }\n        } else {\n          data.currentTranslate = data.startTranslate;\n          return;\n        }\n      }\n      if (!params.followFinger || params.cssMode)\n        return;\n      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n      }\n      swiper.updateProgress(data.currentTranslate);\n      swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event2) {\n      const swiper = this;\n      const data = swiper.touchEventsData;\n      const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event2.pointerId);\n      if (pointerIndex >= 0) {\n        data.evCache.splice(pointerIndex, 1);\n      }\n      if ([\"pointercancel\", \"pointerout\", \"pointerleave\"].includes(event2.type)) {\n        const proceed = event2.type === \"pointercancel\" && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n          return;\n        }\n      }\n      const {\n        params,\n        touches,\n        rtlTranslate: rtl,\n        slidesGrid,\n        enabled\n      } = swiper;\n      if (!enabled)\n        return;\n      if (!params.simulateTouch && event2.pointerType === \"mouse\")\n        return;\n      let e = event2;\n      if (e.originalEvent)\n        e = e.originalEvent;\n      if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchEnd\", e);\n      }\n      data.allowTouchCallbacks = false;\n      if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n          swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n      }\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n      if (swiper.allowClick) {\n        const pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n        swiper.emit(\"tap click\", e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n          swiper.emit(\"doubleTap doubleClick\", e);\n        }\n      }\n      data.lastClickTime = now();\n      nextTick(() => {\n        if (!swiper.destroyed)\n          swiper.allowClick = true;\n      });\n      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n      }\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      let currentPos;\n      if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n      } else {\n        currentPos = -data.currentTranslate;\n      }\n      if (params.cssMode) {\n        return;\n      }\n      if (swiper.params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n          currentPos\n        });\n        return;\n      }\n      let stopIndex = 0;\n      let groupSize = swiper.slidesSizesGrid[0];\n      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n        const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment2] !== \"undefined\") {\n          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {\n            stopIndex = i;\n            groupSize = slidesGrid[i + increment2] - slidesGrid[i];\n          }\n        } else if (currentPos >= slidesGrid[i]) {\n          stopIndex = i;\n          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n      }\n      let rewindFirstIndex = null;\n      let rewindLastIndex = null;\n      if (params.rewind) {\n        if (swiper.isBeginning) {\n          rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n          rewindFirstIndex = 0;\n        }\n      }\n      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (timeDiff > params.longSwipesMs) {\n        if (!params.longSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (swiper.swipeDirection === \"next\") {\n          if (ratio >= params.longSwipesRatio)\n            swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n          else\n            swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === \"prev\") {\n          if (ratio > 1 - params.longSwipesRatio) {\n            swiper.slideTo(stopIndex + increment);\n          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n            swiper.slideTo(rewindLastIndex);\n          } else {\n            swiper.slideTo(stopIndex);\n          }\n        }\n      } else {\n        if (!params.shortSwipes) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n          if (swiper.swipeDirection === \"next\") {\n            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n          }\n          if (swiper.swipeDirection === \"prev\") {\n            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n          }\n        } else if (e.target === swiper.navigation.nextEl) {\n          swiper.slideTo(stopIndex + increment);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    }\n    let timeout;\n    function onResize() {\n      const swiper = this;\n      const {\n        params,\n        el\n      } = swiper;\n      if (el && el.offsetWidth === 0)\n        return;\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n      const {\n        allowSlideNext,\n        allowSlidePrev,\n        snapGrid\n      } = swiper;\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      swiper.allowSlideNext = true;\n      swiper.allowSlidePrev = true;\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateSlidesClasses();\n      const isVirtualLoop = isVirtual && params.loop;\n      if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n      } else {\n        if (swiper.params.loop && !isVirtual) {\n          swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n          swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n      }\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n          if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            swiper.autoplay.resume();\n          }\n        }, 500);\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n    }\n    function onClick(e) {\n      const swiper = this;\n      if (!swiper.enabled)\n        return;\n      if (!swiper.allowClick) {\n        if (swiper.params.preventClicks)\n          e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n          e.stopPropagation();\n          e.stopImmediatePropagation();\n        }\n      }\n    }\n    function onScroll() {\n      const swiper = this;\n      const {\n        wrapperEl,\n        rtlTranslate,\n        enabled\n      } = swiper;\n      if (!enabled)\n        return;\n      swiper.previousTranslate = swiper.translate;\n      if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n      } else {\n        swiper.translate = -wrapperEl.scrollTop;\n      }\n      if (swiper.translate === 0)\n        swiper.translate = 0;\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n      let newProgress;\n      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n      if (translatesDiff === 0) {\n        newProgress = 0;\n      } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n      }\n      if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n      }\n      swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    const processLazyPreloader = (swiper, imageEl) => {\n      if (!swiper || swiper.destroyed || !swiper.params)\n        return;\n      const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      const slideEl = imageEl.closest(slideSelector());\n      if (slideEl) {\n        const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n        if (lazyEl)\n          lazyEl.remove();\n      }\n    };\n    function onLoad(e) {\n      const swiper = this;\n      processLazyPreloader(swiper, e.target);\n      swiper.update();\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {\n    }\n    const events = (swiper, method) => {\n      const document2 = getDocument();\n      const {\n        params,\n        el,\n        wrapperEl,\n        device\n      } = swiper;\n      const capture = !!params.nested;\n      const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n      const swiperMethod = method;\n      el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n        passive: false\n      });\n      document2[domMethod](\"pointermove\", swiper.onTouchMove, {\n        passive: false,\n        capture\n      });\n      document2[domMethod](\"pointerup\", swiper.onTouchEnd, {\n        passive: true\n      });\n      document2[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n        passive: true\n      });\n      document2[domMethod](\"pointerout\", swiper.onTouchEnd, {\n        passive: true\n      });\n      document2[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n        passive: true\n      });\n      if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod](\"click\", swiper.onClick, true);\n      }\n      if (params.cssMode) {\n        wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n      }\n      if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n      } else {\n        swiper[swiperMethod](\"observerUpdate\", onResize, true);\n      }\n      el[domMethod](\"load\", swiper.onLoad, {\n        capture: true\n      });\n    };\n    function attachEvents() {\n      const swiper = this;\n      const document2 = getDocument();\n      const {\n        params\n      } = swiper;\n      swiper.onTouchStart = onTouchStart.bind(swiper);\n      swiper.onTouchMove = onTouchMove.bind(swiper);\n      swiper.onTouchEnd = onTouchEnd.bind(swiper);\n      if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n      }\n      swiper.onClick = onClick.bind(swiper);\n      swiper.onLoad = onLoad.bind(swiper);\n      if (!dummyEventAttached) {\n        document2.addEventListener(\"touchstart\", dummyEventListener);\n        dummyEventAttached = true;\n      }\n      events(swiper, \"on\");\n    }\n    function detachEvents() {\n      const swiper = this;\n      events(swiper, \"off\");\n    }\n    const events$1 = {\n      attachEvents,\n      detachEvents\n    };\n    const isGridEnabled = (swiper, params) => {\n      return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n      const swiper = this;\n      const {\n        realIndex,\n        initialized,\n        params,\n        el\n      } = swiper;\n      const breakpoints2 = params.breakpoints;\n      if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)\n        return;\n      const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);\n      if (!breakpoint || swiper.currentBreakpoint === breakpoint)\n        return;\n      const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;\n      const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n      const wasMultiRow = isGridEnabled(swiper, params);\n      const isMultiRow = isGridEnabled(swiper, breakpointParams);\n      const wasEnabled = params.enabled;\n      if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n        swiper.emitContainerClasses();\n      } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n          el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n      }\n      [\"navigation\", \"pagination\", \"scrollbar\"].forEach((prop) => {\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n          swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n          swiper[prop].enable();\n        }\n      });\n      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n      if (directionChanged && initialized) {\n        swiper.changeDirection();\n      }\n      extend(swiper.params, breakpointParams);\n      const isEnabled = swiper.params.enabled;\n      Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n      });\n      if (wasEnabled && !isEnabled) {\n        swiper.disable();\n      } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n      }\n      swiper.currentBreakpoint = breakpoint;\n      swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n      if (needsReLoop && initialized) {\n        swiper.loopDestroy();\n        swiper.loopCreate(realIndex);\n        swiper.updateSlides();\n      }\n      swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints2, base = \"window\", containerEl) {\n      if (!breakpoints2 || base === \"container\" && !containerEl)\n        return void 0;\n      let breakpoint = false;\n      const window2 = getWindow();\n      const currentHeight = base === \"window\" ? window2.innerHeight : containerEl.clientHeight;\n      const points = Object.keys(breakpoints2).map((point) => {\n        if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n          const minRatio = parseFloat(point.substr(1));\n          const value = currentHeight * minRatio;\n          return {\n            value,\n            point\n          };\n        }\n        return {\n          value: point,\n          point\n        };\n      });\n      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n      for (let i = 0; i < points.length; i += 1) {\n        const {\n          point,\n          value\n        } = points[i];\n        if (base === \"window\") {\n          if (window2.matchMedia(`(min-width: ${value}px)`).matches) {\n            breakpoint = point;\n          }\n        } else if (value <= containerEl.clientWidth) {\n          breakpoint = point;\n        }\n      }\n      return breakpoint || \"max\";\n    }\n    const breakpoints = {\n      setBreakpoint,\n      getBreakpoint\n    };\n    function prepareClasses(entries, prefix) {\n      const resultClasses = [];\n      entries.forEach((item) => {\n        if (typeof item === \"object\") {\n          Object.keys(item).forEach((classNames) => {\n            if (item[classNames]) {\n              resultClasses.push(prefix + classNames);\n            }\n          });\n        } else if (typeof item === \"string\") {\n          resultClasses.push(prefix + item);\n        }\n      });\n      return resultClasses;\n    }\n    function addClasses() {\n      const swiper = this;\n      const {\n        classNames,\n        params,\n        rtl,\n        el,\n        device\n      } = swiper;\n      const suffixes = prepareClasses([\"initialized\", params.direction, {\n        \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n      }, {\n        \"autoheight\": params.autoHeight\n      }, {\n        \"rtl\": rtl\n      }, {\n        \"grid\": params.grid && params.grid.rows > 1\n      }, {\n        \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n      }, {\n        \"android\": device.android\n      }, {\n        \"ios\": device.ios\n      }, {\n        \"css-mode\": params.cssMode\n      }, {\n        \"centered\": params.cssMode && params.centeredSlides\n      }, {\n        \"watch-progress\": params.watchSlidesProgress\n      }], params.containerModifierClass);\n      classNames.push(...suffixes);\n      el.classList.add(...classNames);\n      swiper.emitContainerClasses();\n    }\n    function removeClasses() {\n      const swiper = this;\n      const {\n        el,\n        classNames\n      } = swiper;\n      el.classList.remove(...classNames);\n      swiper.emitContainerClasses();\n    }\n    const classes = {\n      addClasses,\n      removeClasses\n    };\n    function checkOverflow() {\n      const swiper = this;\n      const {\n        isLocked: wasLocked,\n        params\n      } = swiper;\n      const {\n        slidesOffsetBefore\n      } = params;\n      if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n      } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n      }\n      if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n      }\n      if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n      }\n      if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n      }\n      if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n      }\n    }\n    const checkOverflow$1 = {\n      checkOverflow\n    };\n    const defaults = {\n      init: true,\n      direction: \"horizontal\",\n      oneWayMovement: false,\n      touchEventsTarget: \"wrapper\",\n      initialSlide: 0,\n      speed: 300,\n      cssMode: false,\n      updateOnWindowResize: true,\n      resizeObserver: true,\n      nested: false,\n      createElements: false,\n      enabled: true,\n      focusableElements: \"input, select, option, textarea, button, video, label\",\n      // Overrides\n      width: null,\n      height: null,\n      //\n      preventInteractionOnTransition: false,\n      // ssr\n      userAgent: null,\n      url: null,\n      // To support iOS's swipe-to-go-back gesture (when being used in-app).\n      edgeSwipeDetection: false,\n      edgeSwipeThreshold: 20,\n      // Autoheight\n      autoHeight: false,\n      // Set wrapper width\n      setWrapperSize: false,\n      // Virtual Translate\n      virtualTranslate: false,\n      // Effects\n      effect: \"slide\",\n      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n      // Breakpoints\n      breakpoints: void 0,\n      breakpointsBase: \"window\",\n      // Slides grid\n      spaceBetween: 0,\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      slidesPerGroupSkip: 0,\n      slidesPerGroupAuto: false,\n      centeredSlides: false,\n      centeredSlidesBounds: false,\n      slidesOffsetBefore: 0,\n      // in px\n      slidesOffsetAfter: 0,\n      // in px\n      normalizeSlideIndex: true,\n      centerInsufficientSlides: false,\n      // Disable swiper and hide navigation when container not overflow\n      watchOverflow: true,\n      // Round length\n      roundLengths: false,\n      // Touches\n      touchRatio: 1,\n      touchAngle: 45,\n      simulateTouch: true,\n      shortSwipes: true,\n      longSwipes: true,\n      longSwipesRatio: 0.5,\n      longSwipesMs: 300,\n      followFinger: true,\n      allowTouchMove: true,\n      threshold: 5,\n      touchMoveStopPropagation: false,\n      touchStartPreventDefault: true,\n      touchStartForcePreventDefault: false,\n      touchReleaseOnEdges: false,\n      // Unique Navigation Elements\n      uniqueNavElements: true,\n      // Resistance\n      resistance: true,\n      resistanceRatio: 0.85,\n      // Progress\n      watchSlidesProgress: false,\n      // Cursor\n      grabCursor: false,\n      // Clicks\n      preventClicks: true,\n      preventClicksPropagation: true,\n      slideToClickedSlide: false,\n      // loop\n      loop: false,\n      loopedSlides: null,\n      loopPreventsSliding: true,\n      // rewind\n      rewind: false,\n      // Swiping/no swiping\n      allowSlidePrev: true,\n      allowSlideNext: true,\n      swipeHandler: null,\n      // '.swipe-handler',\n      noSwiping: true,\n      noSwipingClass: \"swiper-no-swiping\",\n      noSwipingSelector: null,\n      // Passive Listeners\n      passiveListeners: true,\n      maxBackfaceHiddenSlides: 10,\n      // NS\n      containerModifierClass: \"swiper-\",\n      // NEW\n      slideClass: \"swiper-slide\",\n      slideActiveClass: \"swiper-slide-active\",\n      slideVisibleClass: \"swiper-slide-visible\",\n      slideNextClass: \"swiper-slide-next\",\n      slidePrevClass: \"swiper-slide-prev\",\n      wrapperClass: \"swiper-wrapper\",\n      lazyPreloaderClass: \"swiper-lazy-preloader\",\n      // Callbacks\n      runCallbacksOnInit: true,\n      // Internals\n      _emitClasses: false\n    };\n    function moduleExtendParams(params, allModulesParams) {\n      return function extendParams(obj = {}) {\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== \"object\" || moduleParams === null) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if ([\"navigation\", \"pagination\", \"scrollbar\"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            auto: true\n          };\n        }\n        if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n          extend(allModulesParams, obj);\n          return;\n        }\n        if (params[moduleParamName] === true) {\n          params[moduleParamName] = {\n            enabled: true\n          };\n        }\n        if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n          params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName])\n          params[moduleParamName] = {\n            enabled: false\n          };\n        extend(allModulesParams, obj);\n      };\n    }\n    const prototypes = {\n      eventsEmitter,\n      update,\n      translate,\n      transition,\n      slide,\n      loop,\n      grabCursor,\n      events: events$1,\n      breakpoints,\n      checkOverflow: checkOverflow$1,\n      classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n      constructor(...args) {\n        let el;\n        let params;\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n          params = args[0];\n        } else {\n          [el, params] = args;\n        }\n        if (!params)\n          params = {};\n        params = extend({}, params);\n        if (el && !params.el)\n          params.el = el;\n        const document2 = getDocument();\n        if (params.el && typeof params.el === \"string\" && document2.querySelectorAll(params.el).length > 1) {\n          const swipers = [];\n          document2.querySelectorAll(params.el).forEach((containerEl) => {\n            const newParams = extend({}, params, {\n              el: containerEl\n            });\n            swipers.push(new Swiper(newParams));\n          });\n          return swipers;\n        }\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n          userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [...swiper.__modules__];\n        if (params.modules && Array.isArray(params.modules)) {\n          swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach((mod) => {\n          mod({\n            params,\n            swiper,\n            extendParams: moduleExtendParams(params, allModulesParams),\n            on: swiper.on.bind(swiper),\n            once: swiper.once.bind(swiper),\n            off: swiper.off.bind(swiper),\n            emit: swiper.emit.bind(swiper)\n          });\n        });\n        const swiperParams = extend({}, defaults, allModulesParams);\n        swiper.params = extend({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = extend({}, swiper.params);\n        swiper.passedParams = extend({}, params);\n        if (swiper.params && swiper.params.on) {\n          Object.keys(swiper.params.on).forEach((eventName) => {\n            swiper.on(eventName, swiper.params.on[eventName]);\n          });\n        }\n        if (swiper.params && swiper.params.onAny) {\n          swiper.onAny(swiper.params.onAny);\n        }\n        Object.assign(swiper, {\n          enabled: swiper.params.enabled,\n          el,\n          // Classes\n          classNames: [],\n          // Slides\n          slides: [],\n          slidesGrid: [],\n          snapGrid: [],\n          slidesSizesGrid: [],\n          // isDirection\n          isHorizontal() {\n            return swiper.params.direction === \"horizontal\";\n          },\n          isVertical() {\n            return swiper.params.direction === \"vertical\";\n          },\n          // Indexes\n          activeIndex: 0,\n          realIndex: 0,\n          //\n          isBeginning: true,\n          isEnd: false,\n          // Props\n          translate: 0,\n          previousTranslate: 0,\n          progress: 0,\n          velocity: 0,\n          animating: false,\n          // Locks\n          allowSlideNext: swiper.params.allowSlideNext,\n          allowSlidePrev: swiper.params.allowSlidePrev,\n          // Touch Events\n          touchEventsData: {\n            isTouched: void 0,\n            isMoved: void 0,\n            allowTouchCallbacks: void 0,\n            touchStartTime: void 0,\n            isScrolling: void 0,\n            currentTranslate: void 0,\n            startTranslate: void 0,\n            allowThresholdMove: void 0,\n            // Form elements to match\n            focusableElements: swiper.params.focusableElements,\n            // Last click time\n            lastClickTime: now(),\n            clickTimeout: void 0,\n            // Velocities\n            velocities: [],\n            allowMomentumBounce: void 0,\n            startMoving: void 0,\n            evCache: []\n          },\n          // Clicks\n          allowClick: true,\n          // Touches\n          allowTouchMove: swiper.params.allowTouchMove,\n          touches: {\n            startX: 0,\n            startY: 0,\n            currentX: 0,\n            currentY: 0,\n            diff: 0\n          },\n          // Images\n          imagesToLoad: [],\n          imagesLoaded: 0\n        });\n        swiper.emit(\"_swiper\");\n        if (swiper.params.init) {\n          swiper.init();\n        }\n        return swiper;\n      }\n      getSlideIndex(slideEl) {\n        const {\n          slidesEl,\n          params\n        } = this;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        const firstSlideIndex = elementIndex(slides[0]);\n        return elementIndex(slideEl) - firstSlideIndex;\n      }\n      recalcSlides() {\n        const swiper = this;\n        const {\n          slidesEl,\n          params\n        } = swiper;\n        swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      }\n      enable() {\n        const swiper = this;\n        if (swiper.enabled)\n          return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n          swiper.setGrabCursor();\n        }\n        swiper.emit(\"enable\");\n      }\n      disable() {\n        const swiper = this;\n        if (!swiper.enabled)\n          return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n          swiper.unsetGrabCursor();\n        }\n        swiper.emit(\"disable\");\n      }\n      setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el)\n          return;\n        const cls = swiper.el.className.split(\" \").filter((className) => {\n          return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n        });\n        swiper.emit(\"_containerClasses\", cls.join(\" \"));\n      }\n      getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed)\n          return \"\";\n        return slideEl.className.split(\" \").filter((className) => {\n          return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n        }).join(\" \");\n      }\n      emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el)\n          return;\n        const updates = [];\n        swiper.slides.forEach((slideEl) => {\n          const classNames = swiper.getSlideClasses(slideEl);\n          updates.push({\n            slideEl,\n            classNames\n          });\n          swiper.emit(\"_slideClass\", slideEl, classNames);\n        });\n        swiper.emit(\"_slideClasses\", updates);\n      }\n      slidesPerViewDynamic(view = \"current\", exact = false) {\n        const swiper = this;\n        const {\n          params,\n          slides,\n          slidesGrid,\n          slidesSizesGrid,\n          size: swiperSize,\n          activeIndex\n        } = swiper;\n        let spv = 1;\n        if (params.centeredSlides) {\n          let slideSize = slides[activeIndex].swiperSlideSize;\n          let breakLoop;\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize)\n                breakLoop = true;\n            }\n          }\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            if (slides[i] && !breakLoop) {\n              slideSize += slides[i].swiperSlideSize;\n              spv += 1;\n              if (slideSize > swiperSize)\n                breakLoop = true;\n            }\n          }\n        } else {\n          if (view === \"current\") {\n            for (let i = activeIndex + 1; i < slides.length; i += 1) {\n              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          } else {\n            for (let i = activeIndex - 1; i >= 0; i -= 1) {\n              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n              if (slideInView) {\n                spv += 1;\n              }\n            }\n          }\n        }\n        return spv;\n      }\n      update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed)\n          return;\n        const {\n          snapGrid,\n          params\n        } = swiper;\n        if (params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          }\n        });\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate2() {\n          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n          swiper.setTranslate(newTranslate);\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n          setTranslate2();\n          if (swiper.params.autoHeight) {\n            swiper.updateAutoHeight();\n          }\n        } else {\n          if ((swiper.params.slidesPerView === \"auto\" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\n            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n          } else {\n            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n          }\n          if (!translated) {\n            setTranslate2();\n          }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n          swiper.checkOverflow();\n        }\n        swiper.emit(\"update\");\n      }\n      changeDirection(newDirection, needUpdate = true) {\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n          newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n        }\n        if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n          return swiper;\n        }\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach((slideEl) => {\n          if (newDirection === \"vertical\") {\n            slideEl.style.width = \"\";\n          } else {\n            slideEl.style.height = \"\";\n          }\n        });\n        swiper.emit(\"changeDirection\");\n        if (needUpdate)\n          swiper.update();\n        return swiper;\n      }\n      changeLanguageDirection(direction) {\n        const swiper = this;\n        if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\")\n          return;\n        swiper.rtl = direction === \"rtl\";\n        swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n        if (swiper.rtl) {\n          swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = \"rtl\";\n        } else {\n          swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n          swiper.el.dir = \"ltr\";\n        }\n        swiper.update();\n      }\n      mount(element) {\n        const swiper = this;\n        if (swiper.mounted)\n          return true;\n        let el = element || swiper.params.el;\n        if (typeof el === \"string\") {\n          el = document.querySelector(el);\n        }\n        if (!el) {\n          return false;\n        }\n        el.swiper = swiper;\n        if (el.shadowEl) {\n          swiper.isElement = true;\n        }\n        const getWrapperSelector = () => {\n          return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n        };\n        const getWrapper = () => {\n          if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n            const res = el.shadowRoot.querySelector(getWrapperSelector());\n            return res;\n          }\n          return elementChildren(el, getWrapperSelector())[0];\n        };\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n          wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n          el.append(wrapperEl);\n          elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {\n            wrapperEl.append(slideEl);\n          });\n        }\n        Object.assign(swiper, {\n          el,\n          wrapperEl,\n          slidesEl: swiper.isElement ? el : wrapperEl,\n          mounted: true,\n          // RTL\n          rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n          rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n          wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n        });\n        return true;\n      }\n      init(el) {\n        const swiper = this;\n        if (swiper.initialized)\n          return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false)\n          return swiper;\n        swiper.emit(\"beforeInit\");\n        if (swiper.params.breakpoints) {\n          swiper.setBreakpoint();\n        }\n        swiper.addClasses();\n        swiper.updateSize();\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n          swiper.checkOverflow();\n        }\n        if (swiper.params.grabCursor && swiper.enabled) {\n          swiper.setGrabCursor();\n        }\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n          swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n        } else {\n          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n        }\n        if (swiper.params.loop) {\n          swiper.loopCreate();\n        }\n        swiper.attachEvents();\n        [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach((imageEl) => {\n          if (imageEl.complete) {\n            processLazyPreloader(swiper, imageEl);\n          } else {\n            imageEl.addEventListener(\"load\", (e) => {\n              processLazyPreloader(swiper, e.target);\n            });\n          }\n        });\n        swiper.initialized = true;\n        swiper.emit(\"init\");\n        swiper.emit(\"afterInit\");\n        return swiper;\n      }\n      destroy(deleteInstance = true, cleanStyles = true) {\n        const swiper = this;\n        const {\n          params,\n          el,\n          wrapperEl,\n          slides\n        } = swiper;\n        if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n          return null;\n        }\n        swiper.emit(\"beforeDestroy\");\n        swiper.initialized = false;\n        swiper.detachEvents();\n        if (params.loop) {\n          swiper.loopDestroy();\n        }\n        if (cleanStyles) {\n          swiper.removeClasses();\n          el.removeAttribute(\"style\");\n          wrapperEl.removeAttribute(\"style\");\n          if (slides && slides.length) {\n            slides.forEach((slideEl) => {\n              slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n              slideEl.removeAttribute(\"style\");\n              slideEl.removeAttribute(\"data-swiper-slide-index\");\n            });\n          }\n        }\n        swiper.emit(\"destroy\");\n        Object.keys(swiper.eventsListeners).forEach((eventName) => {\n          swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n          swiper.el.swiper = null;\n          deleteProps(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n      }\n      static extendDefaults(newDefaults) {\n        extend(extendedDefaults, newDefaults);\n      }\n      static get extendedDefaults() {\n        return extendedDefaults;\n      }\n      static get defaults() {\n        return defaults;\n      }\n      static installModule(mod) {\n        if (!Swiper.prototype.__modules__)\n          Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n          modules.push(mod);\n        }\n      }\n      static use(module) {\n        if (Array.isArray(module)) {\n          module.forEach((m) => Swiper.installModule(m));\n          return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n      }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup) => {\n      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n      });\n    });\n    Swiper.use([Resize, Observer]);\n    function Virtual({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      extendParams({\n        virtual: {\n          enabled: false,\n          slides: [],\n          cache: true,\n          renderSlide: null,\n          renderExternal: null,\n          renderExternalUpdate: true,\n          addSlidesBefore: 0,\n          addSlidesAfter: 0\n        }\n      });\n      let cssModeTimeout;\n      const document2 = getDocument();\n      swiper.virtual = {\n        cache: {},\n        from: void 0,\n        to: void 0,\n        slides: [],\n        offset: 0,\n        slidesGrid: []\n      };\n      const tempDOM = document2.createElement(\"div\");\n      function renderSlide(slide2, index) {\n        const params = swiper.params.virtual;\n        if (params.cache && swiper.virtual.cache[index]) {\n          return swiper.virtual.cache[index];\n        }\n        let slideEl;\n        if (params.renderSlide) {\n          slideEl = params.renderSlide.call(swiper, slide2, index);\n          if (typeof slideEl === \"string\") {\n            tempDOM.innerHTML = slideEl;\n            slideEl = tempDOM.children[0];\n          }\n        } else if (swiper.isElement) {\n          slideEl = createElement(\"swiper-slide\");\n        } else {\n          slideEl = createElement(\"div\", swiper.params.slideClass);\n        }\n        slideEl.setAttribute(\"data-swiper-slide-index\", index);\n        if (!params.renderSlide) {\n          slideEl.innerHTML = slide2;\n        }\n        if (params.cache)\n          swiper.virtual.cache[index] = slideEl;\n        return slideEl;\n      }\n      function update2(force) {\n        const {\n          slidesPerView,\n          slidesPerGroup,\n          centeredSlides,\n          loop: isLoop\n        } = swiper.params;\n        const {\n          addSlidesBefore,\n          addSlidesAfter\n        } = swiper.params.virtual;\n        const {\n          from: previousFrom,\n          to: previousTo,\n          slides,\n          slidesGrid: previousSlidesGrid,\n          offset: previousOffset\n        } = swiper.virtual;\n        if (!swiper.params.cssMode) {\n          swiper.updateActiveIndex();\n        }\n        const activeIndex = swiper.activeIndex || 0;\n        let offsetProp;\n        if (swiper.rtlTranslate)\n          offsetProp = \"right\";\n        else\n          offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n        let slidesAfter;\n        let slidesBefore;\n        if (centeredSlides) {\n          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n        } else {\n          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n          slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n        }\n        let from = activeIndex - slidesBefore;\n        let to = activeIndex + slidesAfter;\n        if (!isLoop) {\n          from = Math.max(from, 0);\n          to = Math.min(to, slides.length - 1);\n        }\n        let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n        if (isLoop && activeIndex >= slidesBefore) {\n          from -= slidesBefore;\n          if (!centeredSlides)\n            offset += swiper.slidesGrid[0];\n        } else if (isLoop && activeIndex < slidesBefore) {\n          from = -slidesBefore;\n          if (centeredSlides)\n            offset += swiper.slidesGrid[0];\n        }\n        Object.assign(swiper.virtual, {\n          from,\n          to,\n          offset,\n          slidesGrid: swiper.slidesGrid,\n          slidesBefore,\n          slidesAfter\n        });\n        function onRendered() {\n          swiper.updateSlides();\n          swiper.updateProgress();\n          swiper.updateSlidesClasses();\n          emit(\"virtualUpdate\");\n        }\n        if (previousFrom === from && previousTo === to && !force) {\n          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n            swiper.slides.forEach((slideEl) => {\n              slideEl.style[offsetProp] = `${offset}px`;\n            });\n          }\n          swiper.updateProgress();\n          emit(\"virtualUpdate\");\n          return;\n        }\n        if (swiper.params.virtual.renderExternal) {\n          swiper.params.virtual.renderExternal.call(swiper, {\n            offset,\n            from,\n            to,\n            slides: function getSlides() {\n              const slidesToRender = [];\n              for (let i = from; i <= to; i += 1) {\n                slidesToRender.push(slides[i]);\n              }\n              return slidesToRender;\n            }()\n          });\n          if (swiper.params.virtual.renderExternalUpdate) {\n            onRendered();\n          } else {\n            emit(\"virtualUpdate\");\n          }\n          return;\n        }\n        const prependIndexes = [];\n        const appendIndexes = [];\n        const getSlideIndex = (index) => {\n          let slideIndex = index;\n          if (index < 0) {\n            slideIndex = slides.length + index;\n          } else if (slideIndex >= slides.length) {\n            slideIndex = slideIndex - slides.length;\n          }\n          return slideIndex;\n        };\n        if (force) {\n          swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach((slideEl) => {\n            slideEl.remove();\n          });\n        } else {\n          for (let i = previousFrom; i <= previousTo; i += 1) {\n            if (i < from || i > to) {\n              const slideIndex = getSlideIndex(i);\n              swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach((slideEl) => {\n                slideEl.remove();\n              });\n            }\n          }\n        }\n        const loopFrom = isLoop ? -slides.length : 0;\n        const loopTo = isLoop ? slides.length * 2 : slides.length;\n        for (let i = loopFrom; i < loopTo; i += 1) {\n          if (i >= from && i <= to) {\n            const slideIndex = getSlideIndex(i);\n            if (typeof previousTo === \"undefined\" || force) {\n              appendIndexes.push(slideIndex);\n            } else {\n              if (i > previousTo)\n                appendIndexes.push(slideIndex);\n              if (i < previousFrom)\n                prependIndexes.push(slideIndex);\n            }\n          }\n        }\n        appendIndexes.forEach((index) => {\n          swiper.slidesEl.append(renderSlide(slides[index], index));\n        });\n        if (isLoop) {\n          for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n            const index = prependIndexes[i];\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          }\n        } else {\n          prependIndexes.sort((a, b) => b - a);\n          prependIndexes.forEach((index) => {\n            swiper.slidesEl.prepend(renderSlide(slides[index], index));\n          });\n        }\n        elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach((slideEl) => {\n          slideEl.style[offsetProp] = `${offset}px`;\n        });\n        onRendered();\n      }\n      function appendSlide2(slides) {\n        if (typeof slides === \"object\" && \"length\" in slides) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i])\n              swiper.virtual.slides.push(slides[i]);\n          }\n        } else {\n          swiper.virtual.slides.push(slides);\n        }\n        update2(true);\n      }\n      function prependSlide2(slides) {\n        const activeIndex = swiper.activeIndex;\n        let newActiveIndex = activeIndex + 1;\n        let numberOfNewSlides = 1;\n        if (Array.isArray(slides)) {\n          for (let i = 0; i < slides.length; i += 1) {\n            if (slides[i])\n              swiper.virtual.slides.unshift(slides[i]);\n          }\n          newActiveIndex = activeIndex + slides.length;\n          numberOfNewSlides = slides.length;\n        } else {\n          swiper.virtual.slides.unshift(slides);\n        }\n        if (swiper.params.virtual.cache) {\n          const cache = swiper.virtual.cache;\n          const newCache = {};\n          Object.keys(cache).forEach((cachedIndex) => {\n            const cachedEl = cache[cachedIndex];\n            const cachedElIndex = cachedEl.getAttribute(\"data-swiper-slide-index\");\n            if (cachedElIndex) {\n              cachedEl.setAttribute(\"data-swiper-slide-index\", parseInt(cachedElIndex, 10) + numberOfNewSlides);\n            }\n            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n          });\n          swiper.virtual.cache = newCache;\n        }\n        update2(true);\n        swiper.slideTo(newActiveIndex, 0);\n      }\n      function removeSlide2(slidesIndexes) {\n        if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null)\n          return;\n        let activeIndex = swiper.activeIndex;\n        if (Array.isArray(slidesIndexes)) {\n          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n            swiper.virtual.slides.splice(slidesIndexes[i], 1);\n            if (swiper.params.virtual.cache) {\n              delete swiper.virtual.cache[slidesIndexes[i]];\n            }\n            if (slidesIndexes[i] < activeIndex)\n              activeIndex -= 1;\n            activeIndex = Math.max(activeIndex, 0);\n          }\n        } else {\n          swiper.virtual.slides.splice(slidesIndexes, 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes];\n          }\n          if (slidesIndexes < activeIndex)\n            activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n        update2(true);\n        swiper.slideTo(activeIndex, 0);\n      }\n      function removeAllSlides2() {\n        swiper.virtual.slides = [];\n        if (swiper.params.virtual.cache) {\n          swiper.virtual.cache = {};\n        }\n        update2(true);\n        swiper.slideTo(0, 0);\n      }\n      on(\"beforeInit\", () => {\n        if (!swiper.params.virtual.enabled)\n          return;\n        let domSlidesAssigned;\n        if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n          const slides = [...swiper.slidesEl.children].filter((el) => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n          if (slides && slides.length) {\n            swiper.virtual.slides = [...slides];\n            domSlidesAssigned = true;\n            slides.forEach((slideEl, slideIndex) => {\n              slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n              swiper.virtual.cache[slideIndex] = slideEl;\n              slideEl.remove();\n            });\n          }\n        }\n        if (!domSlidesAssigned) {\n          swiper.virtual.slides = swiper.params.virtual.slides;\n        }\n        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n        if (!swiper.params.initialSlide) {\n          update2();\n        }\n      });\n      on(\"setTranslate\", () => {\n        if (!swiper.params.virtual.enabled)\n          return;\n        if (swiper.params.cssMode && !swiper._immediateVirtual) {\n          clearTimeout(cssModeTimeout);\n          cssModeTimeout = setTimeout(() => {\n            update2();\n          }, 100);\n        } else {\n          update2();\n        }\n      });\n      on(\"init update resize\", () => {\n        if (!swiper.params.virtual.enabled)\n          return;\n        if (swiper.params.cssMode) {\n          setCSSProperty(swiper.wrapperEl, \"--swiper-virtual-size\", `${swiper.virtualSize}px`);\n        }\n      });\n      Object.assign(swiper.virtual, {\n        appendSlide: appendSlide2,\n        prependSlide: prependSlide2,\n        removeSlide: removeSlide2,\n        removeAllSlides: removeAllSlides2,\n        update: update2\n      });\n    }\n    function Keyboard({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const document2 = getDocument();\n      const window2 = getWindow();\n      swiper.keyboard = {\n        enabled: false\n      };\n      extendParams({\n        keyboard: {\n          enabled: false,\n          onlyInViewport: true,\n          pageUpDown: true\n        }\n      });\n      function handle(event2) {\n        if (!swiper.enabled)\n          return;\n        const {\n          rtlTranslate: rtl\n        } = swiper;\n        let e = event2;\n        if (e.originalEvent)\n          e = e.originalEvent;\n        const kc = e.keyCode || e.charCode;\n        const pageUpDown = swiper.params.keyboard.pageUpDown;\n        const isPageUp = pageUpDown && kc === 33;\n        const isPageDown = pageUpDown && kc === 34;\n        const isArrowLeft = kc === 37;\n        const isArrowRight = kc === 39;\n        const isArrowUp = kc === 38;\n        const isArrowDown = kc === 40;\n        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n          return false;\n        }\n        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n          return false;\n        }\n        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n          return void 0;\n        }\n        if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === \"input\" || document2.activeElement.nodeName.toLowerCase() === \"textarea\")) {\n          return void 0;\n        }\n        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n          let inView = false;\n          if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n            return void 0;\n          }\n          const el = swiper.el;\n          const swiperWidth = el.clientWidth;\n          const swiperHeight = el.clientHeight;\n          const windowWidth = window2.innerWidth;\n          const windowHeight = window2.innerHeight;\n          const swiperOffset = elementOffset(el);\n          if (rtl)\n            swiperOffset.left -= el.scrollLeft;\n          const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n          for (let i = 0; i < swiperCoord.length; i += 1) {\n            const point = swiperCoord[i];\n            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n              if (point[0] === 0 && point[1] === 0)\n                continue;\n              inView = true;\n            }\n          }\n          if (!inView)\n            return void 0;\n        }\n        if (swiper.isHorizontal()) {\n          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n            if (e.preventDefault)\n              e.preventDefault();\n            else\n              e.returnValue = false;\n          }\n          if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)\n            swiper.slideNext();\n          if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)\n            swiper.slidePrev();\n        } else {\n          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n            if (e.preventDefault)\n              e.preventDefault();\n            else\n              e.returnValue = false;\n          }\n          if (isPageDown || isArrowDown)\n            swiper.slideNext();\n          if (isPageUp || isArrowUp)\n            swiper.slidePrev();\n        }\n        emit(\"keyPress\", kc);\n        return void 0;\n      }\n      function enable() {\n        if (swiper.keyboard.enabled)\n          return;\n        document2.addEventListener(\"keydown\", handle);\n        swiper.keyboard.enabled = true;\n      }\n      function disable() {\n        if (!swiper.keyboard.enabled)\n          return;\n        document2.removeEventListener(\"keydown\", handle);\n        swiper.keyboard.enabled = false;\n      }\n      on(\"init\", () => {\n        if (swiper.params.keyboard.enabled) {\n          enable();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.keyboard.enabled) {\n          disable();\n        }\n      });\n      Object.assign(swiper.keyboard, {\n        enable,\n        disable\n      });\n    }\n    function Mousewheel({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const window2 = getWindow();\n      extendParams({\n        mousewheel: {\n          enabled: false,\n          releaseOnEdges: false,\n          invert: false,\n          forceToAxis: false,\n          sensitivity: 1,\n          eventsTarget: \"container\",\n          thresholdDelta: null,\n          thresholdTime: null\n        }\n      });\n      swiper.mousewheel = {\n        enabled: false\n      };\n      let timeout2;\n      let lastScrollTime = now();\n      let lastEventBeforeSnap;\n      const recentWheelEvents = [];\n      function normalize(e) {\n        const PIXEL_STEP = 10;\n        const LINE_HEIGHT = 40;\n        const PAGE_HEIGHT = 800;\n        let sX = 0;\n        let sY = 0;\n        let pX = 0;\n        let pY = 0;\n        if (\"detail\" in e) {\n          sY = e.detail;\n        }\n        if (\"wheelDelta\" in e) {\n          sY = -e.wheelDelta / 120;\n        }\n        if (\"wheelDeltaY\" in e) {\n          sY = -e.wheelDeltaY / 120;\n        }\n        if (\"wheelDeltaX\" in e) {\n          sX = -e.wheelDeltaX / 120;\n        }\n        if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n          sX = sY;\n          sY = 0;\n        }\n        pX = sX * PIXEL_STEP;\n        pY = sY * PIXEL_STEP;\n        if (\"deltaY\" in e) {\n          pY = e.deltaY;\n        }\n        if (\"deltaX\" in e) {\n          pX = e.deltaX;\n        }\n        if (e.shiftKey && !pX) {\n          pX = pY;\n          pY = 0;\n        }\n        if ((pX || pY) && e.deltaMode) {\n          if (e.deltaMode === 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n          } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n          }\n        }\n        if (pX && !sX) {\n          sX = pX < 1 ? -1 : 1;\n        }\n        if (pY && !sY) {\n          sY = pY < 1 ? -1 : 1;\n        }\n        return {\n          spinX: sX,\n          spinY: sY,\n          pixelX: pX,\n          pixelY: pY\n        };\n      }\n      function handleMouseEnter() {\n        if (!swiper.enabled)\n          return;\n        swiper.mouseEntered = true;\n      }\n      function handleMouseLeave() {\n        if (!swiper.enabled)\n          return;\n        swiper.mouseEntered = false;\n      }\n      function animateSlider(newEvent) {\n        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n          return false;\n        }\n        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n          return false;\n        }\n        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n          return true;\n        }\n        if (newEvent.direction < 0) {\n          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n            swiper.slideNext();\n            emit(\"scroll\", newEvent.raw);\n          }\n        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n          swiper.slidePrev();\n          emit(\"scroll\", newEvent.raw);\n        }\n        lastScrollTime = new window2.Date().getTime();\n        return false;\n      }\n      function releaseScroll(newEvent) {\n        const params = swiper.params.mousewheel;\n        if (newEvent.direction < 0) {\n          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n            return true;\n          }\n        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n          return true;\n        }\n        return false;\n      }\n      function handle(event2) {\n        let e = event2;\n        let disableParentSwiper = true;\n        if (!swiper.enabled)\n          return;\n        const params = swiper.params.mousewheel;\n        if (swiper.params.cssMode) {\n          e.preventDefault();\n        }\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n        if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)\n          return true;\n        if (e.originalEvent)\n          e = e.originalEvent;\n        let delta = 0;\n        const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n        const data = normalize(e);\n        if (params.forceToAxis) {\n          if (swiper.isHorizontal()) {\n            if (Math.abs(data.pixelX) > Math.abs(data.pixelY))\n              delta = -data.pixelX * rtlFactor;\n            else\n              return true;\n          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))\n            delta = -data.pixelY;\n          else\n            return true;\n        } else {\n          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n        }\n        if (delta === 0)\n          return true;\n        if (params.invert)\n          delta = -delta;\n        let positions = swiper.getTranslate() + delta * params.sensitivity;\n        if (positions >= swiper.minTranslate())\n          positions = swiper.minTranslate();\n        if (positions <= swiper.maxTranslate())\n          positions = swiper.maxTranslate();\n        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n        if (disableParentSwiper && swiper.params.nested)\n          e.stopPropagation();\n        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta),\n            raw: event2\n          };\n          if (recentWheelEvents.length >= 2) {\n            recentWheelEvents.shift();\n          }\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n          recentWheelEvents.push(newEvent);\n          if (prevEvent) {\n            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n              animateSlider(newEvent);\n            }\n          } else {\n            animateSlider(newEvent);\n          }\n          if (releaseScroll(newEvent)) {\n            return true;\n          }\n        } else {\n          const newEvent = {\n            time: now(),\n            delta: Math.abs(delta),\n            direction: Math.sign(delta)\n          };\n          const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n          if (!ignoreWheelEvents) {\n            lastEventBeforeSnap = void 0;\n            let position = swiper.getTranslate() + delta * params.sensitivity;\n            const wasBeginning = swiper.isBeginning;\n            const wasEnd = swiper.isEnd;\n            if (position >= swiper.minTranslate())\n              position = swiper.minTranslate();\n            if (position <= swiper.maxTranslate())\n              position = swiper.maxTranslate();\n            swiper.setTransition(0);\n            swiper.setTranslate(position);\n            swiper.updateProgress();\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n              swiper.updateSlidesClasses();\n            }\n            if (swiper.params.loop) {\n              swiper.loopFix({\n                direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n                byMousewheel: true\n              });\n            }\n            if (swiper.params.freeMode.sticky) {\n              clearTimeout(timeout2);\n              timeout2 = void 0;\n              if (recentWheelEvents.length >= 15) {\n                recentWheelEvents.shift();\n              }\n              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n              const firstEvent = recentWheelEvents[0];\n              recentWheelEvents.push(newEvent);\n              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n                recentWheelEvents.splice(0);\n              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                timeout2 = nextTick(() => {\n                  swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n                }, 0);\n              }\n              if (!timeout2) {\n                timeout2 = nextTick(() => {\n                  const snapToThreshold = 0.5;\n                  lastEventBeforeSnap = newEvent;\n                  recentWheelEvents.splice(0);\n                  swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n                }, 500);\n              }\n            }\n            if (!ignoreWheelEvents)\n              emit(\"scroll\", e);\n            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n              swiper.autoplay.stop();\n            if (position === swiper.minTranslate() || position === swiper.maxTranslate())\n              return true;\n          }\n        }\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n        return false;\n      }\n      function events2(method) {\n        let targetEl = swiper.el;\n        if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n          targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n        }\n        targetEl[method](\"mouseenter\", handleMouseEnter);\n        targetEl[method](\"mouseleave\", handleMouseLeave);\n        targetEl[method](\"wheel\", handle);\n      }\n      function enable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n          return true;\n        }\n        if (swiper.mousewheel.enabled)\n          return false;\n        events2(\"addEventListener\");\n        swiper.mousewheel.enabled = true;\n        return true;\n      }\n      function disable() {\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.addEventListener(event, handle);\n          return true;\n        }\n        if (!swiper.mousewheel.enabled)\n          return false;\n        events2(\"removeEventListener\");\n        swiper.mousewheel.enabled = false;\n        return true;\n      }\n      on(\"init\", () => {\n        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n          disable();\n        }\n        if (swiper.params.mousewheel.enabled)\n          enable();\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.cssMode) {\n          enable();\n        }\n        if (swiper.mousewheel.enabled)\n          disable();\n      });\n      Object.assign(swiper.mousewheel, {\n        enable,\n        disable\n      });\n    }\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n      if (swiper.params.createElements) {\n        Object.keys(checkProps).forEach((key) => {\n          if (!params[key] && params.auto === true) {\n            let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n            if (!element) {\n              element = createElement(\"div\", checkProps[key]);\n              element.className = checkProps[key];\n              swiper.el.append(element);\n            }\n            params[key] = element;\n            originalParams[key] = element;\n          }\n        });\n      }\n      return params;\n    }\n    function Navigation({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      extendParams({\n        navigation: {\n          nextEl: null,\n          prevEl: null,\n          hideOnClick: false,\n          disabledClass: \"swiper-button-disabled\",\n          hiddenClass: \"swiper-button-hidden\",\n          lockClass: \"swiper-button-lock\",\n          navigationDisabledClass: \"swiper-navigation-disabled\"\n        }\n      });\n      swiper.navigation = {\n        nextEl: null,\n        prevEl: null\n      };\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el))\n          el = [el].filter((e) => !!e);\n        return el;\n      };\n      function getEl(el) {\n        let res;\n        if (el && typeof el === \"string\" && swiper.isElement) {\n          res = swiper.el.shadowRoot.querySelector(el);\n          if (res)\n            return res;\n        }\n        if (el) {\n          if (typeof el === \"string\")\n            res = [...document.querySelectorAll(el)];\n          if (swiper.params.uniqueNavElements && typeof el === \"string\" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n            res = swiper.el.querySelector(el);\n          }\n        }\n        if (el && !res)\n          return el;\n        return res;\n      }\n      function toggleEl(el, disabled) {\n        const params = swiper.params.navigation;\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          if (subEl) {\n            subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n            if (subEl.tagName === \"BUTTON\")\n              subEl.disabled = disabled;\n            if (swiper.params.watchOverflow && swiper.enabled) {\n              subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n            }\n          }\n        });\n      }\n      function update2() {\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (swiper.params.loop) {\n          toggleEl(prevEl, false);\n          toggleEl(nextEl, false);\n          return;\n        }\n        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n      }\n      function onPrevClick(e) {\n        e.preventDefault();\n        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)\n          return;\n        swiper.slidePrev();\n        emit(\"navigationPrev\");\n      }\n      function onNextClick(e) {\n        e.preventDefault();\n        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)\n          return;\n        swiper.slideNext();\n        emit(\"navigationNext\");\n      }\n      function init() {\n        const params = swiper.params.navigation;\n        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n          nextEl: \"swiper-button-next\",\n          prevEl: \"swiper-button-prev\"\n        });\n        if (!(params.nextEl || params.prevEl))\n          return;\n        let nextEl = getEl(params.nextEl);\n        let prevEl = getEl(params.prevEl);\n        Object.assign(swiper.navigation, {\n          nextEl,\n          prevEl\n        });\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const initButton = (el, dir) => {\n          if (el) {\n            el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n          }\n          if (!swiper.enabled && el) {\n            el.classList.add(...params.lockClass.split(\" \"));\n          }\n        };\n        nextEl.forEach((el) => initButton(el, \"next\"));\n        prevEl.forEach((el) => initButton(el, \"prev\"));\n      }\n      function destroy() {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const destroyButton = (el, dir) => {\n          el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n          el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n        };\n        nextEl.forEach((el) => destroyButton(el, \"next\"));\n        prevEl.forEach((el) => destroyButton(el, \"prev\"));\n      }\n      on(\"init\", () => {\n        if (swiper.params.navigation.enabled === false) {\n          disable();\n        } else {\n          init();\n          update2();\n        }\n      });\n      on(\"toEdge fromEdge lock unlock\", () => {\n        update2();\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      on(\"enable disable\", () => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.navigation.lockClass));\n      });\n      on(\"click\", (_s, e) => {\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        const targetEl = e.target;\n        if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))\n            return;\n          let isHidden;\n          if (nextEl.length) {\n            isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          } else if (prevEl.length) {\n            isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n          }\n          if (isHidden === true) {\n            emit(\"navigationShow\");\n          } else {\n            emit(\"navigationHide\");\n          }\n          [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n        init();\n        update2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n        destroy();\n      };\n      Object.assign(swiper.navigation, {\n        enable,\n        disable,\n        update: update2,\n        init,\n        destroy\n      });\n    }\n    function classesToSelector(classes2 = \"\") {\n      return `.${classes2.trim().replace(/([\\.:!\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}`;\n    }\n    function Pagination({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const pfx = \"swiper-pagination\";\n      extendParams({\n        pagination: {\n          el: null,\n          bulletElement: \"span\",\n          clickable: false,\n          hideOnClick: false,\n          renderBullet: null,\n          renderProgressbar: null,\n          renderFraction: null,\n          renderCustom: null,\n          progressbarOpposite: false,\n          type: \"bullets\",\n          // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n          dynamicBullets: false,\n          dynamicMainBullets: 1,\n          formatFractionCurrent: (number) => number,\n          formatFractionTotal: (number) => number,\n          bulletClass: `${pfx}-bullet`,\n          bulletActiveClass: `${pfx}-bullet-active`,\n          modifierClass: `${pfx}-`,\n          currentClass: `${pfx}-current`,\n          totalClass: `${pfx}-total`,\n          hiddenClass: `${pfx}-hidden`,\n          progressbarFillClass: `${pfx}-progressbar-fill`,\n          progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n          clickableClass: `${pfx}-clickable`,\n          lockClass: `${pfx}-lock`,\n          horizontalClass: `${pfx}-horizontal`,\n          verticalClass: `${pfx}-vertical`,\n          paginationDisabledClass: `${pfx}-disabled`\n        }\n      });\n      swiper.pagination = {\n        el: null,\n        bullets: []\n      };\n      let bulletSize;\n      let dynamicBulletIndex = 0;\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el))\n          el = [el].filter((e) => !!e);\n        return el;\n      };\n      function isPaginationDisabled() {\n        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n      }\n      function setSideBullets(bulletEl, position) {\n        const {\n          bulletActiveClass\n        } = swiper.params.pagination;\n        if (!bulletEl)\n          return;\n        bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n          bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n          if (bulletEl) {\n            bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n          }\n        }\n      }\n      function onBulletClick(e) {\n        const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n        if (!bulletEl) {\n          return;\n        }\n        e.preventDefault();\n        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) {\n          if (swiper.realIndex === index)\n            return;\n          if (index < swiper.loopedSlides || index > swiper.slides.length - swiper.loopedSlides) {\n            swiper.loopFix({\n              direction: index < swiper.loopedSlides ? \"prev\" : \"next\",\n              activeSlideIndex: index,\n              slideTo: false\n            });\n          }\n          swiper.slideToLoop(index);\n        } else {\n          swiper.slideTo(index);\n        }\n      }\n      function update2() {\n        const rtl = swiper.rtl;\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled())\n          return;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let current;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n        if (swiper.params.loop) {\n          current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n        } else if (typeof swiper.snapIndex !== \"undefined\") {\n          current = swiper.snapIndex;\n        } else {\n          current = swiper.activeIndex || 0;\n        }\n        if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n          const bullets = swiper.pagination.bullets;\n          let firstIndex;\n          let lastIndex;\n          let midIndex;\n          if (params.dynamicBullets) {\n            bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n            el.forEach((subEl) => {\n              subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n            });\n            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {\n              dynamicBulletIndex += current - (swiper.previousIndex || 0);\n              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n                dynamicBulletIndex = params.dynamicMainBullets - 1;\n              } else if (dynamicBulletIndex < 0) {\n                dynamicBulletIndex = 0;\n              }\n            }\n            firstIndex = Math.max(current - dynamicBulletIndex, 0);\n            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n            midIndex = (lastIndex + firstIndex) / 2;\n          }\n          bullets.forEach((bulletEl) => {\n            bulletEl.classList.remove(...[\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map((suffix) => `${params.bulletActiveClass}${suffix}`));\n          });\n          if (el.length > 1) {\n            bullets.forEach((bullet) => {\n              const bulletIndex = elementIndex(bullet);\n              if (bulletIndex === current) {\n                bullet.classList.add(params.bulletActiveClass);\n              }\n              if (params.dynamicBullets) {\n                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                  bullet.classList.add(`${params.bulletActiveClass}-main`);\n                }\n                if (bulletIndex === firstIndex) {\n                  setSideBullets(bullet, \"prev\");\n                }\n                if (bulletIndex === lastIndex) {\n                  setSideBullets(bullet, \"next\");\n                }\n              }\n            });\n          } else {\n            const bullet = bullets[current];\n            if (bullet) {\n              bullet.classList.add(params.bulletActiveClass);\n            }\n            if (params.dynamicBullets) {\n              const firstDisplayedBullet = bullets[firstIndex];\n              const lastDisplayedBullet = bullets[lastIndex];\n              for (let i = firstIndex; i <= lastIndex; i += 1) {\n                if (bullets[i]) {\n                  bullets[i].classList.add(`${params.bulletActiveClass}-main`);\n                }\n              }\n              setSideBullets(firstDisplayedBullet, \"prev\");\n              setSideBullets(lastDisplayedBullet, \"next\");\n            }\n          }\n          if (params.dynamicBullets) {\n            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n            const offsetProp = rtl ? \"right\" : \"left\";\n            bullets.forEach((bullet) => {\n              bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n            });\n          }\n        }\n        el.forEach((subEl, subElIndex) => {\n          if (params.type === \"fraction\") {\n            subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {\n              fractionEl.textContent = params.formatFractionCurrent(current + 1);\n            });\n            subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {\n              totalEl.textContent = params.formatFractionTotal(total);\n            });\n          }\n          if (params.type === \"progressbar\") {\n            let progressbarDirection;\n            if (params.progressbarOpposite) {\n              progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n            } else {\n              progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n            }\n            const scale = (current + 1) / total;\n            let scaleX = 1;\n            let scaleY = 1;\n            if (progressbarDirection === \"horizontal\") {\n              scaleX = scale;\n            } else {\n              scaleY = scale;\n            }\n            subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {\n              progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n              progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            });\n          }\n          if (params.type === \"custom\" && params.renderCustom) {\n            subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n            if (subElIndex === 0)\n              emit(\"paginationRender\", subEl);\n          } else {\n            if (subElIndex === 0)\n              emit(\"paginationRender\", subEl);\n            emit(\"paginationUpdate\", subEl);\n          }\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n          }\n        });\n      }\n      function render() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled())\n          return;\n        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n        let el = swiper.pagination.el;\n        el = makeElementsArray(el);\n        let paginationHTML = \"\";\n        if (params.type === \"bullets\") {\n          let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n          if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n            numberOfBullets = slidesLength;\n          }\n          for (let i = 0; i < numberOfBullets; i += 1) {\n            if (params.renderBullet) {\n              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n            } else {\n              paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n          }\n        }\n        if (params.type === \"fraction\") {\n          if (params.renderFraction) {\n            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n          } else {\n            paginationHTML = `<span class=\"${params.currentClass}\"></span> / <span class=\"${params.totalClass}\"></span>`;\n          }\n        }\n        if (params.type === \"progressbar\") {\n          if (params.renderProgressbar) {\n            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n          } else {\n            paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n          }\n        }\n        el.forEach((subEl) => {\n          if (params.type !== \"custom\") {\n            subEl.innerHTML = paginationHTML || \"\";\n          }\n          if (params.type === \"bullets\") {\n            swiper.pagination.bullets = [...subEl.querySelectorAll(classesToSelector(params.bulletClass))];\n          }\n        });\n        if (params.type !== \"custom\") {\n          emit(\"paginationRender\", el[0]);\n        }\n      }\n      function init() {\n        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n          el: \"swiper-pagination\"\n        });\n        const params = swiper.params.pagination;\n        if (!params.el)\n          return;\n        let el;\n        if (typeof params.el === \"string\" && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === \"string\") {\n          el = [...document.querySelectorAll(params.el)];\n        }\n        if (!el) {\n          el = params.el;\n        }\n        if (!el || el.length === 0)\n          return;\n        if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n          el = [...swiper.el.querySelectorAll(params.el)];\n          if (el.length > 1) {\n            el = el.filter((subEl) => {\n              if (elementParents(subEl, \".swiper\")[0] !== swiper.el)\n                return false;\n              return true;\n            })[0];\n          }\n        }\n        if (Array.isArray(el) && el.length === 1)\n          el = el[0];\n        Object.assign(swiper.pagination, {\n          el\n        });\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          if (params.type === \"bullets\" && params.clickable) {\n            subEl.classList.add(params.clickableClass);\n          }\n          subEl.classList.add(params.modifierClass + params.type);\n          subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n          if (params.type === \"bullets\" && params.dynamicBullets) {\n            subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n            dynamicBulletIndex = 0;\n            if (params.dynamicMainBullets < 1) {\n              params.dynamicMainBullets = 1;\n            }\n          }\n          if (params.type === \"progressbar\" && params.progressbarOpposite) {\n            subEl.classList.add(params.progressbarOppositeClass);\n          }\n          if (params.clickable) {\n            subEl.addEventListener(\"click\", onBulletClick);\n          }\n          if (!swiper.enabled) {\n            subEl.classList.add(params.lockClass);\n          }\n        });\n      }\n      function destroy() {\n        const params = swiper.params.pagination;\n        if (isPaginationDisabled())\n          return;\n        let el = swiper.pagination.el;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) => {\n            subEl.classList.remove(params.hiddenClass);\n            subEl.classList.remove(params.modifierClass + params.type);\n            subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            if (params.clickable) {\n              subEl.removeEventListener(\"click\", onBulletClick);\n            }\n          });\n        }\n        if (swiper.pagination.bullets)\n          swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(params.bulletActiveClass));\n      }\n      on(\"init\", () => {\n        if (swiper.params.pagination.enabled === false) {\n          disable();\n        } else {\n          init();\n          render();\n          update2();\n        }\n      });\n      on(\"activeIndexChange\", () => {\n        if (typeof swiper.snapIndex === \"undefined\") {\n          update2();\n        }\n      });\n      on(\"snapIndexChange\", () => {\n        update2();\n      });\n      on(\"snapGridLengthChange\", () => {\n        render();\n        update2();\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      on(\"enable disable\", () => {\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) => subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n        }\n      });\n      on(\"lock unlock\", () => {\n        update2();\n      });\n      on(\"click\", (_s, e) => {\n        const targetEl = e.target;\n        let {\n          el\n        } = swiper.pagination;\n        if (!Array.isArray(el))\n          el = [el].filter((element) => !!element);\n        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n            return;\n          const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n          if (isHidden === true) {\n            emit(\"paginationShow\");\n          } else {\n            emit(\"paginationHide\");\n          }\n          el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n        }\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n        }\n        init();\n        render();\n        update2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n        let {\n          el\n        } = swiper.pagination;\n        if (el) {\n          el = makeElementsArray(el);\n          el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n        }\n        destroy();\n      };\n      Object.assign(swiper.pagination, {\n        enable,\n        disable,\n        render,\n        update: update2,\n        init,\n        destroy\n      });\n    }\n    function Scrollbar({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const document2 = getDocument();\n      let isTouched = false;\n      let timeout2 = null;\n      let dragTimeout = null;\n      let dragStartPos;\n      let dragSize;\n      let trackSize;\n      let divider;\n      extendParams({\n        scrollbar: {\n          el: null,\n          dragSize: \"auto\",\n          hide: false,\n          draggable: false,\n          snapOnRelease: true,\n          lockClass: \"swiper-scrollbar-lock\",\n          dragClass: \"swiper-scrollbar-drag\",\n          scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n          horizontalClass: `swiper-scrollbar-horizontal`,\n          verticalClass: `swiper-scrollbar-vertical`\n        }\n      });\n      swiper.scrollbar = {\n        el: null,\n        dragEl: null\n      };\n      function setTranslate2() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n          return;\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        const params = swiper.params.scrollbar;\n        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n        let newSize = dragSize;\n        let newPos = (trackSize - dragSize) * progress;\n        if (rtl) {\n          newPos = -newPos;\n          if (newPos > 0) {\n            newSize = dragSize - newPos;\n            newPos = 0;\n          } else if (-newPos + dragSize > trackSize) {\n            newSize = trackSize + newPos;\n          }\n        } else if (newPos < 0) {\n          newSize = dragSize + newPos;\n          newPos = 0;\n        } else if (newPos + dragSize > trackSize) {\n          newSize = trackSize - newPos;\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n          dragEl.style.width = `${newSize}px`;\n        } else {\n          dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n          dragEl.style.height = `${newSize}px`;\n        }\n        if (params.hide) {\n          clearTimeout(timeout2);\n          el.style.opacity = 1;\n          timeout2 = setTimeout(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = \"400ms\";\n          }, 1e3);\n        }\n      }\n      function setTransition2(duration) {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n          return;\n        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n      }\n      function updateSize2() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n          return;\n        const {\n          scrollbar\n        } = swiper;\n        const {\n          dragEl,\n          el\n        } = scrollbar;\n        dragEl.style.width = \"\";\n        dragEl.style.height = \"\";\n        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n        if (swiper.params.scrollbar.dragSize === \"auto\") {\n          dragSize = trackSize * divider;\n        } else {\n          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n        }\n        if (swiper.isHorizontal()) {\n          dragEl.style.width = `${dragSize}px`;\n        } else {\n          dragEl.style.height = `${dragSize}px`;\n        }\n        if (divider >= 1) {\n          el.style.display = \"none\";\n        } else {\n          el.style.display = \"\";\n        }\n        if (swiper.params.scrollbar.hide) {\n          el.style.opacity = 0;\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function getPointerPosition(e) {\n        return swiper.isHorizontal() ? e.clientX : e.clientY;\n      }\n      function setDragPosition(e) {\n        const {\n          scrollbar,\n          rtlTranslate: rtl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        let positionRatio;\n        positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n        positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n        if (rtl) {\n          positionRatio = 1 - positionRatio;\n        }\n        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n        swiper.updateProgress(position);\n        swiper.setTranslate(position);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      function onDragStart(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        isTouched = true;\n        dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? \"left\" : \"top\"] : null;\n        e.preventDefault();\n        e.stopPropagation();\n        wrapperEl.style.transitionDuration = \"100ms\";\n        dragEl.style.transitionDuration = \"100ms\";\n        setDragPosition(e);\n        clearTimeout(dragTimeout);\n        el.style.transitionDuration = \"0ms\";\n        if (params.hide) {\n          el.style.opacity = 1;\n        }\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n        }\n        emit(\"scrollbarDragStart\", e);\n      }\n      function onDragMove(e) {\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el,\n          dragEl\n        } = scrollbar;\n        if (!isTouched)\n          return;\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n        setDragPosition(e);\n        wrapperEl.style.transitionDuration = \"0ms\";\n        el.style.transitionDuration = \"0ms\";\n        dragEl.style.transitionDuration = \"0ms\";\n        emit(\"scrollbarDragMove\", e);\n      }\n      function onDragEnd(e) {\n        const params = swiper.params.scrollbar;\n        const {\n          scrollbar,\n          wrapperEl\n        } = swiper;\n        const {\n          el\n        } = scrollbar;\n        if (!isTouched)\n          return;\n        isTouched = false;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n          wrapperEl.style.transitionDuration = \"\";\n        }\n        if (params.hide) {\n          clearTimeout(dragTimeout);\n          dragTimeout = nextTick(() => {\n            el.style.opacity = 0;\n            el.style.transitionDuration = \"400ms\";\n          }, 1e3);\n        }\n        emit(\"scrollbarDragEnd\", e);\n        if (params.snapOnRelease) {\n          swiper.slideToClosest();\n        }\n      }\n      function events2(method) {\n        const {\n          scrollbar,\n          params\n        } = swiper;\n        const el = scrollbar.el;\n        if (!el)\n          return;\n        const target = el;\n        const activeListener = params.passiveListeners ? {\n          passive: false,\n          capture: false\n        } : false;\n        const passiveListener = params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        if (!target)\n          return;\n        const eventMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n        target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n        document2[eventMethod](\"pointermove\", onDragMove, activeListener);\n        document2[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n      }\n      function enableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n          return;\n        events2(\"on\");\n      }\n      function disableDraggable() {\n        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)\n          return;\n        events2(\"off\");\n      }\n      function init() {\n        const {\n          scrollbar,\n          el: swiperEl\n        } = swiper;\n        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n          el: \"swiper-scrollbar\"\n        });\n        const params = swiper.params.scrollbar;\n        if (!params.el)\n          return;\n        let el;\n        if (typeof params.el === \"string\" && swiper.isElement) {\n          el = swiper.el.shadowRoot.querySelector(params.el);\n        }\n        if (!el && typeof params.el === \"string\") {\n          el = document2.querySelectorAll(params.el);\n        } else if (!el) {\n          el = params.el;\n        }\n        if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n          el = swiperEl.querySelector(params.el);\n        }\n        if (el.length > 0)\n          el = el[0];\n        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        let dragEl;\n        if (el) {\n          dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n          if (!dragEl) {\n            dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n            el.append(dragEl);\n          }\n        }\n        Object.assign(scrollbar, {\n          el,\n          dragEl\n        });\n        if (params.draggable) {\n          enableDraggable();\n        }\n        if (el) {\n          el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        }\n      }\n      function destroy() {\n        const params = swiper.params.scrollbar;\n        const el = swiper.scrollbar.el;\n        if (el) {\n          el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        }\n        disableDraggable();\n      }\n      on(\"init\", () => {\n        if (swiper.params.scrollbar.enabled === false) {\n          disable();\n        } else {\n          init();\n          updateSize2();\n          setTranslate2();\n        }\n      });\n      on(\"update resize observerUpdate lock unlock\", () => {\n        updateSize2();\n      });\n      on(\"setTranslate\", () => {\n        setTranslate2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        setTransition2(duration);\n      });\n      on(\"enable disable\", () => {\n        const {\n          el\n        } = swiper.scrollbar;\n        if (el) {\n          el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        }\n      });\n      on(\"destroy\", () => {\n        destroy();\n      });\n      const enable = () => {\n        swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        init();\n        updateSize2();\n        setTranslate2();\n      };\n      const disable = () => {\n        swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        if (swiper.scrollbar.el) {\n          swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n        }\n        destroy();\n      };\n      Object.assign(swiper.scrollbar, {\n        enable,\n        disable,\n        updateSize: updateSize2,\n        setTranslate: setTranslate2,\n        init,\n        destroy\n      });\n    }\n    function Parallax({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        parallax: {\n          enabled: false\n        }\n      });\n      const setTransform = (el, progress) => {\n        const {\n          rtl\n        } = swiper;\n        const rtlFactor = rtl ? -1 : 1;\n        const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n        let x = el.getAttribute(\"data-swiper-parallax-x\");\n        let y = el.getAttribute(\"data-swiper-parallax-y\");\n        const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n        const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n        const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n        if (x || y) {\n          x = x || \"0\";\n          y = y || \"0\";\n        } else if (swiper.isHorizontal()) {\n          x = p;\n          y = \"0\";\n        } else {\n          y = p;\n          x = \"0\";\n        }\n        if (x.indexOf(\"%\") >= 0) {\n          x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n        } else {\n          x = `${x * progress * rtlFactor}px`;\n        }\n        if (y.indexOf(\"%\") >= 0) {\n          y = `${parseInt(y, 10) * progress}%`;\n        } else {\n          y = `${y * progress}px`;\n        }\n        if (typeof opacity !== \"undefined\" && opacity !== null) {\n          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n          el.style.opacity = currentOpacity;\n        }\n        let transform = `translate3d(${x}, ${y}, 0px)`;\n        if (typeof scale !== \"undefined\" && scale !== null) {\n          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n          transform += ` scale(${currentScale})`;\n        }\n        if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n          const currentRotate = rotate * progress * -1;\n          transform += ` rotate(${currentRotate}deg)`;\n        }\n        el.style.transform = transform;\n      };\n      const setTranslate2 = () => {\n        const {\n          el,\n          slides,\n          progress,\n          snapGrid\n        } = swiper;\n        elementChildren(el, \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((subEl) => {\n          setTransform(subEl, progress);\n        });\n        slides.forEach((slideEl, slideIndex) => {\n          let slideProgress = slideEl.progress;\n          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== \"auto\") {\n            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n          }\n          slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n          slideEl.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\").forEach((subEl) => {\n            setTransform(subEl, slideProgress);\n          });\n        });\n      };\n      const setTransition2 = (duration = swiper.params.speed) => {\n        const {\n          el\n        } = swiper;\n        el.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((parallaxEl) => {\n          let parallaxDuration = parseInt(parallaxEl.getAttribute(\"data-swiper-parallax-duration\"), 10) || duration;\n          if (duration === 0)\n            parallaxDuration = 0;\n          parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n        });\n      };\n      on(\"beforeInit\", () => {\n        if (!swiper.params.parallax.enabled)\n          return;\n        swiper.params.watchSlidesProgress = true;\n        swiper.originalParams.watchSlidesProgress = true;\n      });\n      on(\"init\", () => {\n        if (!swiper.params.parallax.enabled)\n          return;\n        setTranslate2();\n      });\n      on(\"setTranslate\", () => {\n        if (!swiper.params.parallax.enabled)\n          return;\n        setTranslate2();\n      });\n      on(\"setTransition\", (_swiper, duration) => {\n        if (!swiper.params.parallax.enabled)\n          return;\n        setTransition2(duration);\n      });\n    }\n    function Zoom({\n      swiper,\n      extendParams,\n      on,\n      emit\n    }) {\n      const window2 = getWindow();\n      extendParams({\n        zoom: {\n          enabled: false,\n          maxRatio: 3,\n          minRatio: 1,\n          toggle: true,\n          containerClass: \"swiper-zoom-container\",\n          zoomedSlideClass: \"swiper-slide-zoomed\"\n        }\n      });\n      swiper.zoom = {\n        enabled: false\n      };\n      let currentScale = 1;\n      let isScaling = false;\n      let fakeGestureTouched;\n      let fakeGestureMoved;\n      const evCache = [];\n      const gesture = {\n        slideEl: void 0,\n        slideWidth: void 0,\n        slideHeight: void 0,\n        imageEl: void 0,\n        imageWrapEl: void 0,\n        maxRatio: 3\n      };\n      const image = {\n        isTouched: void 0,\n        isMoved: void 0,\n        currentX: void 0,\n        currentY: void 0,\n        minX: void 0,\n        minY: void 0,\n        maxX: void 0,\n        maxY: void 0,\n        width: void 0,\n        height: void 0,\n        startX: void 0,\n        startY: void 0,\n        touchesStart: {},\n        touchesCurrent: {}\n      };\n      const velocity = {\n        x: void 0,\n        y: void 0,\n        prevPositionX: void 0,\n        prevPositionY: void 0,\n        prevTime: void 0\n      };\n      let scale = 1;\n      Object.defineProperty(swiper.zoom, \"scale\", {\n        get() {\n          return scale;\n        },\n        set(value) {\n          if (scale !== value) {\n            const imageEl = gesture.imageEl;\n            const slideEl = gesture.slideEl;\n            emit(\"zoomChange\", value, imageEl, slideEl);\n          }\n          scale = value;\n        }\n      });\n      function getDistanceBetweenTouches() {\n        if (evCache.length < 2)\n          return 1;\n        const x1 = evCache[0].pageX;\n        const y1 = evCache[0].pageY;\n        const x2 = evCache[1].pageX;\n        const y2 = evCache[1].pageY;\n        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        return distance;\n      }\n      function getScaleOrigin() {\n        if (evCache.length < 2)\n          return {\n            x: null,\n            y: null\n          };\n        const box = gesture.imageEl.getBoundingClientRect();\n        return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n      }\n      function getSlideSelector() {\n        return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n      }\n      function eventWithinSlide(e) {\n        const slideSelector = getSlideSelector();\n        if (e.target.matches(slideSelector))\n          return true;\n        if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0)\n          return true;\n        return false;\n      }\n      function eventWithinZoomContainer(e) {\n        const selector = `.${swiper.params.zoom.containerClass}`;\n        if (e.target.matches(selector))\n          return true;\n        if ([...swiper.el.querySelectorAll(selector)].filter((containerEl) => containerEl.contains(e.target)).length > 0)\n          return true;\n        return false;\n      }\n      function onGestureStart(e) {\n        if (e.pointerType === \"mouse\") {\n          evCache.splice(0, evCache.length);\n        }\n        if (!eventWithinSlide(e))\n          return;\n        const params = swiper.params.zoom;\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        evCache.push(e);\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureTouched = true;\n        gesture.scaleStart = getDistanceBetweenTouches();\n        if (!gesture.slideEl) {\n          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          if (!gesture.slideEl)\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n          if (!gesture.imageWrapEl) {\n            gesture.imageEl = void 0;\n            return;\n          }\n          gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n        }\n        if (gesture.imageEl) {\n          const [originX, originY] = getScaleOrigin();\n          gesture.imageEl.style.transformOrigin = `${originX}px ${originY}px`;\n          gesture.imageEl.style.transitionDuration = \"0ms\";\n        }\n        isScaling = true;\n      }\n      function onGestureChange(e) {\n        if (!eventWithinSlide(e))\n          return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0)\n          evCache[pointerIndex] = e;\n        if (evCache.length < 2) {\n          return;\n        }\n        fakeGestureMoved = true;\n        gesture.scaleMove = getDistanceBetweenTouches();\n        if (!gesture.imageEl) {\n          return;\n        }\n        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n        if (zoom.scale > gesture.maxRatio) {\n          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n        }\n        if (zoom.scale < params.minRatio) {\n          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n        }\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function onGestureEnd(e) {\n        if (!eventWithinSlide(e))\n          return;\n        if (e.pointerType === \"mouse\" && e.type === \"pointerout\")\n          return;\n        const params = swiper.params.zoom;\n        const zoom = swiper.zoom;\n        const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0)\n          evCache.splice(pointerIndex, 1);\n        if (!fakeGestureTouched || !fakeGestureMoved) {\n          return;\n        }\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n        if (!gesture.imageEl)\n          return;\n        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        currentScale = zoom.scale;\n        isScaling = false;\n        if (zoom.scale === 1)\n          gesture.slideEl = void 0;\n      }\n      function onTouchStart2(e) {\n        const device = swiper.device;\n        if (!gesture.imageEl)\n          return;\n        if (image.isTouched)\n          return;\n        if (device.android && e.cancelable)\n          e.preventDefault();\n        image.isTouched = true;\n        image.touchesStart.x = e.pageX;\n        image.touchesStart.y = e.pageY;\n      }\n      function onTouchMove2(e) {\n        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e))\n          return;\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl)\n          return;\n        swiper.allowClick = false;\n        if (!image.isTouched || !gesture.slideEl)\n          return;\n        if (!image.isMoved) {\n          image.width = gesture.imageEl.offsetWidth;\n          image.height = gesture.imageEl.offsetHeight;\n          image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n          image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n          gesture.slideWidth = gesture.slideEl.offsetWidth;\n          gesture.slideHeight = gesture.slideEl.offsetHeight;\n          gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n        }\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)\n          return;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n        image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n        if (!image.isMoved && !isScaling) {\n          if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n            image.isTouched = false;\n            return;\n          }\n          if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n            image.isTouched = false;\n            return;\n          }\n        }\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n        e.stopPropagation();\n        image.isMoved = true;\n        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;\n        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;\n        if (image.currentX < image.minX) {\n          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n        }\n        if (image.currentX > image.maxX) {\n          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n        }\n        if (image.currentY < image.minY) {\n          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n        }\n        if (image.currentY > image.maxY) {\n          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n        }\n        if (!velocity.prevPositionX)\n          velocity.prevPositionX = image.touchesCurrent.x;\n        if (!velocity.prevPositionY)\n          velocity.prevPositionY = image.touchesCurrent.y;\n        if (!velocity.prevTime)\n          velocity.prevTime = Date.now();\n        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)\n          velocity.x = 0;\n        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)\n          velocity.y = 0;\n        velocity.prevPositionX = image.touchesCurrent.x;\n        velocity.prevPositionY = image.touchesCurrent.y;\n        velocity.prevTime = Date.now();\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTouchEnd2() {\n        const zoom = swiper.zoom;\n        if (!gesture.imageEl)\n          return;\n        if (!image.isTouched || !image.isMoved) {\n          image.isTouched = false;\n          image.isMoved = false;\n          return;\n        }\n        image.isTouched = false;\n        image.isMoved = false;\n        let momentumDurationX = 300;\n        let momentumDurationY = 300;\n        const momentumDistanceX = velocity.x * momentumDurationX;\n        const newPositionX = image.currentX + momentumDistanceX;\n        const momentumDistanceY = velocity.y * momentumDurationY;\n        const newPositionY = image.currentY + momentumDistanceY;\n        if (velocity.x !== 0)\n          momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n        if (velocity.y !== 0)\n          momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n        image.currentX = newPositionX;\n        image.currentY = newPositionY;\n        const scaledWidth = image.width * zoom.scale;\n        const scaledHeight = image.height * zoom.scale;\n        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n        image.maxX = -image.minX;\n        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n        image.maxY = -image.minY;\n        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n      }\n      function onTransitionEnd() {\n        const zoom = swiper.zoom;\n        if (gesture.slideEl && swiper.previousIndex !== swiper.activeIndex) {\n          if (gesture.imageEl) {\n            gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n          }\n          if (gesture.imageWrapEl) {\n            gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n          }\n          zoom.scale = 1;\n          currentScale = 1;\n          gesture.slideEl = void 0;\n          gesture.imageEl = void 0;\n          gesture.imageWrapEl = void 0;\n        }\n      }\n      function zoomIn(e) {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (e && e.target) {\n            gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n          }\n          if (!gesture.slideEl) {\n            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n              gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n            } else {\n              gesture.slideEl = swiper.slides[swiper.activeIndex];\n            }\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl)\n          return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = \"hidden\";\n          swiper.wrapperEl.style.touchAction = \"none\";\n        }\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n        let touchX;\n        let touchY;\n        let offsetX;\n        let offsetY;\n        let diffX;\n        let diffY;\n        let translateX;\n        let translateY;\n        let imageWidth;\n        let imageHeight;\n        let scaledWidth;\n        let scaledHeight;\n        let translateMinX;\n        let translateMinY;\n        let translateMaxX;\n        let translateMaxY;\n        let slideWidth;\n        let slideHeight;\n        if (typeof image.touchesStart.x === \"undefined\" && e) {\n          touchX = e.pageX;\n          touchY = e.pageY;\n        } else {\n          touchX = image.touchesStart.x;\n          touchY = image.touchesStart.y;\n        }\n        const forceZoomRatio = typeof e === \"number\" ? e : null;\n        if (currentScale === 1 && forceZoomRatio) {\n          touchX = void 0;\n          touchY = void 0;\n        }\n        zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n        currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n        if (e && !(currentScale === 1 && forceZoomRatio)) {\n          slideWidth = gesture.slideEl.offsetWidth;\n          slideHeight = gesture.slideEl.offsetHeight;\n          offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;\n          offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;\n          diffX = offsetX + slideWidth / 2 - touchX;\n          diffY = offsetY + slideHeight / 2 - touchY;\n          imageWidth = gesture.imageEl.offsetWidth;\n          imageHeight = gesture.imageEl.offsetHeight;\n          scaledWidth = imageWidth * zoom.scale;\n          scaledHeight = imageHeight * zoom.scale;\n          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n          translateMaxX = -translateMinX;\n          translateMaxY = -translateMinY;\n          translateX = diffX * zoom.scale;\n          translateY = diffY * zoom.scale;\n          if (translateX < translateMinX) {\n            translateX = translateMinX;\n          }\n          if (translateX > translateMaxX) {\n            translateX = translateMaxX;\n          }\n          if (translateY < translateMinY) {\n            translateY = translateMinY;\n          }\n          if (translateY > translateMaxY) {\n            translateY = translateMaxY;\n          }\n        } else {\n          translateX = 0;\n          translateY = 0;\n        }\n        gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n        gesture.imageEl.style.transitionDuration = \"300ms\";\n        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      }\n      function zoomOut() {\n        const zoom = swiper.zoom;\n        const params = swiper.params.zoom;\n        if (!gesture.slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n          let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n          if (imageEl) {\n            imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n          }\n          gesture.imageEl = imageEl;\n          if (imageEl) {\n            gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n          } else {\n            gesture.imageWrapEl = void 0;\n          }\n        }\n        if (!gesture.imageEl || !gesture.imageWrapEl)\n          return;\n        if (swiper.params.cssMode) {\n          swiper.wrapperEl.style.overflow = \"\";\n          swiper.wrapperEl.style.touchAction = \"\";\n        }\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n        gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n        gesture.imageEl.style.transitionDuration = \"300ms\";\n        gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n        gesture.slideEl = void 0;\n      }\n      function zoomToggle(e) {\n        const zoom = swiper.zoom;\n        if (zoom.scale && zoom.scale !== 1) {\n          zoomOut();\n        } else {\n          zoomIn(e);\n        }\n      }\n      function getListeners() {\n        const passiveListener = swiper.params.passiveListeners ? {\n          passive: true,\n          capture: false\n        } : false;\n        const activeListenerWithCapture = swiper.params.passiveListeners ? {\n          passive: false,\n          capture: true\n        } : true;\n        return {\n          passiveListener,\n          activeListenerWithCapture\n        };\n      }\n      function enable() {\n        const zoom = swiper.zoom;\n        if (zoom.enabled)\n          return;\n        zoom.enabled = true;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n        swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n        swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n        [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n          swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n        });\n        swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove2, activeListenerWithCapture);\n      }\n      function disable() {\n        const zoom = swiper.zoom;\n        if (!zoom.enabled)\n          return;\n        zoom.enabled = false;\n        const {\n          passiveListener,\n          activeListenerWithCapture\n        } = getListeners();\n        swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n        swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n        [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n          swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n        });\n        swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove2, activeListenerWithCapture);\n      }\n      on(\"init\", () => {\n        if (swiper.params.zoom.enabled) {\n          enable();\n        }\n      });\n      on(\"destroy\", () => {\n        disable();\n      });\n      on(\"touchStart\", (_s, e) => {\n        if (!swiper.zoom.enabled)\n          return;\n        onTouchStart2(e);\n      });\n      on(\"touchEnd\", (_s, e) => {\n        if (!swiper.zoom.enabled)\n          return;\n        onTouchEnd2(e);\n      });\n      on(\"doubleTap\", (_s, e) => {\n        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n          zoomToggle(e);\n        }\n      });\n      on(\"transitionEnd\", () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n          onTransitionEnd();\n        }\n      });\n      on(\"slideChange\", () => {\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n          onTransitionEnd();\n        }\n      });\n      Object.assign(swiper.zoom, {\n        enable,\n        disable,\n        in: zoomIn,\n        out: zoomOut,\n        toggle: zoomToggle\n      });\n    }\n    function Controller({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        controller: {\n          control: void 0,\n          inverse: false,\n          by: \"slide\"\n          // or 'container'\n        }\n      });\n      swiper.controller = {\n        control: void 0\n      };\n      function LinearSpline(x, y) {\n        const binarySearch = function search() {\n          let maxIndex;\n          let minIndex;\n          let guess;\n          return (array, val) => {\n            minIndex = -1;\n            maxIndex = array.length;\n            while (maxIndex - minIndex > 1) {\n              guess = maxIndex + minIndex >> 1;\n              if (array[guess] <= val) {\n                minIndex = guess;\n              } else {\n                maxIndex = guess;\n              }\n            }\n            return maxIndex;\n          };\n        }();\n        this.x = x;\n        this.y = y;\n        this.lastIndex = x.length - 1;\n        let i1;\n        let i3;\n        this.interpolate = function interpolate(x2) {\n          if (!x2)\n            return 0;\n          i3 = binarySearch(this.x, x2);\n          i1 = i3 - 1;\n          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n        };\n        return this;\n      }\n      function getInterpolateFunction(c) {\n        if (!swiper.controller.spline) {\n          swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n      }\n      function setTranslate2(_t, byController) {\n        const controlled = swiper.controller.control;\n        let multiplier;\n        let controlledTranslate;\n        const Swiper2 = swiper.constructor;\n        function setControlledTranslate(c) {\n          const translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n          if (swiper.params.controller.by === \"slide\") {\n            getInterpolateFunction(c);\n            controlledTranslate = -swiper.controller.spline.interpolate(-translate2);\n          }\n          if (!controlledTranslate || swiper.params.controller.by === \"container\") {\n            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n            controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c.minTranslate();\n          }\n          if (swiper.params.controller.inverse) {\n            controlledTranslate = c.maxTranslate() - controlledTranslate;\n          }\n          c.updateProgress(controlledTranslate);\n          c.setTranslate(controlledTranslate, swiper);\n          c.updateActiveIndex();\n          c.updateSlidesClasses();\n        }\n        if (Array.isArray(controlled)) {\n          for (let i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {\n              setControlledTranslate(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper2 && byController !== controlled) {\n          setControlledTranslate(controlled);\n        }\n      }\n      function setTransition2(duration, byController) {\n        const Swiper2 = swiper.constructor;\n        const controlled = swiper.controller.control;\n        let i;\n        function setControlledTransition(c) {\n          c.setTransition(duration, swiper);\n          if (duration !== 0) {\n            c.transitionStart();\n            if (c.params.autoHeight) {\n              nextTick(() => {\n                c.updateAutoHeight();\n              });\n            }\n            elementTransitionEnd(c.wrapperEl, () => {\n              if (!controlled)\n                return;\n              c.transitionEnd();\n            });\n          }\n        }\n        if (Array.isArray(controlled)) {\n          for (i = 0; i < controlled.length; i += 1) {\n            if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {\n              setControlledTransition(controlled[i]);\n            }\n          }\n        } else if (controlled instanceof Swiper2 && byController !== controlled) {\n          setControlledTransition(controlled);\n        }\n      }\n      function removeSpline() {\n        if (!swiper.controller.control)\n          return;\n        if (swiper.controller.spline) {\n          swiper.controller.spline = void 0;\n          delete swiper.controller.spline;\n        }\n      }\n      on(\"beforeInit\", () => {\n        if (typeof window !== \"undefined\" && // eslint-disable-line\n        (typeof swiper.params.controller.control === \"string\" || swiper.params.controller.control instanceof HTMLElement)) {\n          const controlElement = document.querySelector(swiper.params.controller.control);\n          if (controlElement && controlElement.swiper) {\n            swiper.controller.control = controlElement.swiper;\n          } else if (controlElement) {\n            const onControllerSwiper = (e) => {\n              swiper.controller.control = e.detail[0];\n              swiper.update();\n              controlElement.removeEventListener(\"init\", onControllerSwiper);\n            };\n            controlElement.addEventListener(\"init\", onControllerSwiper);\n          }\n          return;\n        }\n        swiper.controller.control = swiper.params.controller.control;\n      });\n      on(\"update\", () => {\n        removeSpline();\n      });\n      on(\"resize\", () => {\n        removeSpline();\n      });\n      on(\"observerUpdate\", () => {\n        removeSpline();\n      });\n      on(\"setTranslate\", (_s, translate2, byController) => {\n        if (!swiper.controller.control)\n          return;\n        swiper.controller.setTranslate(translate2, byController);\n      });\n      on(\"setTransition\", (_s, duration, byController) => {\n        if (!swiper.controller.control)\n          return;\n        swiper.controller.setTransition(duration, byController);\n      });\n      Object.assign(swiper.controller, {\n        setTranslate: setTranslate2,\n        setTransition: setTransition2\n      });\n    }\n    function A11y({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        a11y: {\n          enabled: true,\n          notificationClass: \"swiper-notification\",\n          prevSlideMessage: \"Previous slide\",\n          nextSlideMessage: \"Next slide\",\n          firstSlideMessage: \"This is the first slide\",\n          lastSlideMessage: \"This is the last slide\",\n          paginationBulletMessage: \"Go to slide {{index}}\",\n          slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n          containerMessage: null,\n          containerRoleDescriptionMessage: null,\n          itemRoleDescriptionMessage: null,\n          slideRole: \"group\",\n          id: null\n        }\n      });\n      swiper.a11y = {\n        clicked: false\n      };\n      let liveRegion = null;\n      function notify(message) {\n        const notification = liveRegion;\n        if (notification.length === 0)\n          return;\n        notification.innerHTML = \"\";\n        notification.innerHTML = message;\n      }\n      const makeElementsArray = (el) => {\n        if (!Array.isArray(el))\n          el = [el].filter((e) => !!e);\n        return el;\n      };\n      function getRandomNumber(size = 16) {\n        const randomChar = () => Math.round(16 * Math.random()).toString(16);\n        return \"x\".repeat(size).replace(/x/g, randomChar);\n      }\n      function makeElFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"tabIndex\", \"0\");\n        });\n      }\n      function makeElNotFocusable(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"tabIndex\", \"-1\");\n        });\n      }\n      function addElRole(el, role) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"role\", role);\n        });\n      }\n      function addElRoleDescription(el, description) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-roledescription\", description);\n        });\n      }\n      function addElControls(el, controls) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-controls\", controls);\n        });\n      }\n      function addElLabel(el, label) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-label\", label);\n        });\n      }\n      function addElId(el, id) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"id\", id);\n        });\n      }\n      function addElLive(el, live) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-live\", live);\n        });\n      }\n      function disableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-disabled\", true);\n        });\n      }\n      function enableEl(el) {\n        el = makeElementsArray(el);\n        el.forEach((subEl) => {\n          subEl.setAttribute(\"aria-disabled\", false);\n        });\n      }\n      function onEnterOrSpaceKey(e) {\n        if (e.keyCode !== 13 && e.keyCode !== 32)\n          return;\n        const params = swiper.params.a11y;\n        const targetEl = e.target;\n        if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n          if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass)))\n            return;\n        }\n        if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n          if (!(swiper.isEnd && !swiper.params.loop)) {\n            swiper.slideNext();\n          }\n          if (swiper.isEnd) {\n            notify(params.lastSlideMessage);\n          } else {\n            notify(params.nextSlideMessage);\n          }\n        }\n        if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n          if (!(swiper.isBeginning && !swiper.params.loop)) {\n            swiper.slidePrev();\n          }\n          if (swiper.isBeginning) {\n            notify(params.firstSlideMessage);\n          } else {\n            notify(params.prevSlideMessage);\n          }\n        }\n        if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n          targetEl.click();\n        }\n      }\n      function updateNavigation() {\n        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)\n          return;\n        const {\n          nextEl,\n          prevEl\n        } = swiper.navigation;\n        if (prevEl) {\n          if (swiper.isBeginning) {\n            disableEl(prevEl);\n            makeElNotFocusable(prevEl);\n          } else {\n            enableEl(prevEl);\n            makeElFocusable(prevEl);\n          }\n        }\n        if (nextEl) {\n          if (swiper.isEnd) {\n            disableEl(nextEl);\n            makeElNotFocusable(nextEl);\n          } else {\n            enableEl(nextEl);\n            makeElFocusable(nextEl);\n          }\n        }\n      }\n      function hasPagination() {\n        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n      }\n      function hasClickablePagination() {\n        return hasPagination() && swiper.params.pagination.clickable;\n      }\n      function updatePagination() {\n        const params = swiper.params.a11y;\n        if (!hasPagination())\n          return;\n        swiper.pagination.bullets.forEach((bulletEl) => {\n          if (swiper.params.pagination.clickable) {\n            makeElFocusable(bulletEl);\n            if (!swiper.params.pagination.renderBullet) {\n              addElRole(bulletEl, \"button\");\n              addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n            }\n          }\n          if (bulletEl.matches(`.${swiper.params.pagination.bulletActiveClass}`)) {\n            bulletEl.setAttribute(\"aria-current\", \"true\");\n          } else {\n            bulletEl.removeAttribute(\"aria-current\");\n          }\n        });\n      }\n      const initNavEl = (el, wrapperId, message) => {\n        makeElFocusable(el);\n        if (el.tagName !== \"BUTTON\") {\n          addElRole(el, \"button\");\n          el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n        }\n        addElLabel(el, message);\n        addElControls(el, wrapperId);\n      };\n      const handlePointerDown = () => {\n        swiper.a11y.clicked = true;\n      };\n      const handlePointerUp = () => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            if (!swiper.destroyed) {\n              swiper.a11y.clicked = false;\n            }\n          });\n        });\n      };\n      const handleFocus = (e) => {\n        if (swiper.a11y.clicked)\n          return;\n        const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        if (!slideEl || !swiper.slides.includes(slideEl))\n          return;\n        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n        const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n        if (isActive || isVisible)\n          return;\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents)\n          return;\n        if (swiper.isHorizontal()) {\n          swiper.el.scrollLeft = 0;\n        } else {\n          swiper.el.scrollTop = 0;\n        }\n        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n      };\n      const initSlides = () => {\n        const params = swiper.params.a11y;\n        if (params.itemRoleDescriptionMessage) {\n          addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n        }\n        if (params.slideRole) {\n          addElRole(swiper.slides, params.slideRole);\n        }\n        const slidesLength = swiper.slides.length;\n        if (params.slideLabelMessage) {\n          swiper.slides.forEach((slideEl, index) => {\n            const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10) : index;\n            const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n            addElLabel(slideEl, ariaLabelMessage);\n          });\n        }\n      };\n      const init = () => {\n        const params = swiper.params.a11y;\n        swiper.el.append(liveRegion);\n        const containerEl = swiper.el;\n        if (params.containerRoleDescriptionMessage) {\n          addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n        }\n        if (params.containerMessage) {\n          addElLabel(containerEl, params.containerMessage);\n        }\n        const wrapperEl = swiper.wrapperEl;\n        const wrapperId = params.id || wrapperEl.getAttribute(\"id\") || `swiper-wrapper-${getRandomNumber(16)}`;\n        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? \"off\" : \"polite\";\n        addElId(wrapperEl, wrapperId);\n        addElLive(wrapperEl, live);\n        initSlides();\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));\n        }\n        if (prevEl) {\n          prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));\n        }\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach((el) => {\n            el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n          });\n        }\n        swiper.el.addEventListener(\"focus\", handleFocus, true);\n        swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n        swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n      };\n      function destroy() {\n        if (liveRegion && liveRegion.length > 0)\n          liveRegion.remove();\n        let {\n          nextEl,\n          prevEl\n        } = swiper.navigation ? swiper.navigation : {};\n        nextEl = makeElementsArray(nextEl);\n        prevEl = makeElementsArray(prevEl);\n        if (nextEl) {\n          nextEl.forEach((el) => el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n        }\n        if (prevEl) {\n          prevEl.forEach((el) => el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n        }\n        if (hasClickablePagination()) {\n          const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n          paginationEl.forEach((el) => {\n            el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n          });\n        }\n        swiper.el.removeEventListener(\"focus\", handleFocus, true);\n        swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n        swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n      }\n      on(\"beforeInit\", () => {\n        liveRegion = createElement(\"span\", swiper.params.a11y.notificationClass);\n        liveRegion.setAttribute(\"aria-live\", \"assertive\");\n        liveRegion.setAttribute(\"aria-atomic\", \"true\");\n        if (swiper.isElement) {\n          liveRegion.setAttribute(\"slot\", \"container-end\");\n        }\n      });\n      on(\"afterInit\", () => {\n        if (!swiper.params.a11y.enabled)\n          return;\n        init();\n      });\n      on(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", () => {\n        if (!swiper.params.a11y.enabled)\n          return;\n        initSlides();\n      });\n      on(\"fromEdge toEdge afterInit lock unlock\", () => {\n        if (!swiper.params.a11y.enabled)\n          return;\n        updateNavigation();\n      });\n      on(\"paginationUpdate\", () => {\n        if (!swiper.params.a11y.enabled)\n          return;\n        updatePagination();\n      });\n      on(\"destroy\", () => {\n        if (!swiper.params.a11y.enabled)\n          return;\n        destroy();\n      });\n    }\n    function History({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        history: {\n          enabled: false,\n          root: \"\",\n          replaceState: false,\n          key: \"slides\",\n          keepQuery: false\n        }\n      });\n      let initialized = false;\n      let paths = {};\n      const slugify = (text) => {\n        return text.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n      };\n      const getPathValues = (urlOverride) => {\n        const window2 = getWindow();\n        let location;\n        if (urlOverride) {\n          location = new URL(urlOverride);\n        } else {\n          location = window2.location;\n        }\n        const pathArray = location.pathname.slice(1).split(\"/\").filter((part) => part !== \"\");\n        const total = pathArray.length;\n        const key = pathArray[total - 2];\n        const value = pathArray[total - 1];\n        return {\n          key,\n          value\n        };\n      };\n      const setHistory = (key, index) => {\n        const window2 = getWindow();\n        if (!initialized || !swiper.params.history.enabled)\n          return;\n        let location;\n        if (swiper.params.url) {\n          location = new URL(swiper.params.url);\n        } else {\n          location = window2.location;\n        }\n        const slide2 = swiper.slides[index];\n        let value = slugify(slide2.getAttribute(\"data-history\"));\n        if (swiper.params.history.root.length > 0) {\n          let root = swiper.params.history.root;\n          if (root[root.length - 1] === \"/\")\n            root = root.slice(0, root.length - 1);\n          value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n        } else if (!location.pathname.includes(key)) {\n          value = `${key ? `${key}/` : \"\"}${value}`;\n        }\n        if (swiper.params.history.keepQuery) {\n          value += location.search;\n        }\n        const currentState = window2.history.state;\n        if (currentState && currentState.value === value) {\n          return;\n        }\n        if (swiper.params.history.replaceState) {\n          window2.history.replaceState({\n            value\n          }, null, value);\n        } else {\n          window2.history.pushState({\n            value\n          }, null, value);\n        }\n      };\n      const scrollToSlide = (speed, value, runCallbacks) => {\n        if (value) {\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide2 = swiper.slides[i];\n            const slideHistory = slugify(slide2.getAttribute(\"data-history\"));\n            if (slideHistory === value) {\n              const index = swiper.getSlideIndex(slide2);\n              swiper.slideTo(index, speed, runCallbacks);\n            }\n          }\n        } else {\n          swiper.slideTo(0, speed, runCallbacks);\n        }\n      };\n      const setHistoryPopState = () => {\n        paths = getPathValues(swiper.params.url);\n        scrollToSlide(swiper.params.speed, paths.value, false);\n      };\n      const init = () => {\n        const window2 = getWindow();\n        if (!swiper.params.history)\n          return;\n        if (!window2.history || !window2.history.pushState) {\n          swiper.params.history.enabled = false;\n          swiper.params.hashNavigation.enabled = true;\n          return;\n        }\n        initialized = true;\n        paths = getPathValues(swiper.params.url);\n        if (!paths.key && !paths.value) {\n          if (!swiper.params.history.replaceState) {\n            window2.addEventListener(\"popstate\", setHistoryPopState);\n          }\n          return;\n        }\n        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n        if (!swiper.params.history.replaceState) {\n          window2.addEventListener(\"popstate\", setHistoryPopState);\n        }\n      };\n      const destroy = () => {\n        const window2 = getWindow();\n        if (!swiper.params.history.replaceState) {\n          window2.removeEventListener(\"popstate\", setHistoryPopState);\n        }\n      };\n      on(\"init\", () => {\n        if (swiper.params.history.enabled) {\n          init();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.history.enabled) {\n          destroy();\n        }\n      });\n      on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n        if (initialized) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n      on(\"slideChange\", () => {\n        if (initialized && swiper.params.cssMode) {\n          setHistory(swiper.params.history.key, swiper.activeIndex);\n        }\n      });\n    }\n    function HashNavigation({\n      swiper,\n      extendParams,\n      emit,\n      on\n    }) {\n      let initialized = false;\n      const document2 = getDocument();\n      const window2 = getWindow();\n      extendParams({\n        hashNavigation: {\n          enabled: false,\n          replaceState: false,\n          watchState: false\n        }\n      });\n      const onHashChange = () => {\n        emit(\"hashChange\");\n        const newHash = document2.location.hash.replace(\"#\", \"\");\n        const activeSlideHash = swiper.slides[swiper.activeIndex].getAttribute(\"data-hash\");\n        if (newHash !== activeSlideHash) {\n          const newIndex = swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${newHash}\"], swiper-slide[data-hash=\"${newHash}\"]`)[0]);\n          if (typeof newIndex === \"undefined\")\n            return;\n          swiper.slideTo(newIndex);\n        }\n      };\n      const setHash = () => {\n        if (!initialized || !swiper.params.hashNavigation.enabled)\n          return;\n        if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {\n          window2.history.replaceState(null, null, `#${swiper.slides[swiper.activeIndex].getAttribute(\"data-hash\")}` || \"\");\n          emit(\"hashSet\");\n        } else {\n          const slide2 = swiper.slides[swiper.activeIndex];\n          const hash = slide2.getAttribute(\"data-hash\") || slide2.getAttribute(\"data-history\");\n          document2.location.hash = hash || \"\";\n          emit(\"hashSet\");\n        }\n      };\n      const init = () => {\n        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled)\n          return;\n        initialized = true;\n        const hash = document2.location.hash.replace(\"#\", \"\");\n        if (hash) {\n          const speed = 0;\n          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n            const slide2 = swiper.slides[i];\n            const slideHash = slide2.getAttribute(\"data-hash\") || slide2.getAttribute(\"data-history\");\n            if (slideHash === hash) {\n              const index = swiper.getSlideIndex(slide2);\n              swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n            }\n          }\n        }\n        if (swiper.params.hashNavigation.watchState) {\n          window2.addEventListener(\"hashchange\", onHashChange);\n        }\n      };\n      const destroy = () => {\n        if (swiper.params.hashNavigation.watchState) {\n          window2.removeEventListener(\"hashchange\", onHashChange);\n        }\n      };\n      on(\"init\", () => {\n        if (swiper.params.hashNavigation.enabled) {\n          init();\n        }\n      });\n      on(\"destroy\", () => {\n        if (swiper.params.hashNavigation.enabled) {\n          destroy();\n        }\n      });\n      on(\"transitionEnd _freeModeNoMomentumRelease\", () => {\n        if (initialized) {\n          setHash();\n        }\n      });\n      on(\"slideChange\", () => {\n        if (initialized && swiper.params.cssMode) {\n          setHash();\n        }\n      });\n    }\n    function Autoplay({\n      swiper,\n      extendParams,\n      on,\n      emit,\n      params\n    }) {\n      swiper.autoplay = {\n        running: false,\n        paused: false,\n        timeLeft: 0\n      };\n      extendParams({\n        autoplay: {\n          enabled: false,\n          delay: 3e3,\n          waitForTransition: true,\n          disableOnInteraction: true,\n          stopOnLastSlide: false,\n          reverseDirection: false,\n          pauseOnMouseEnter: false\n        }\n      });\n      let timeout2;\n      let raf;\n      let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;\n      let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;\n      let autoplayTimeLeft;\n      let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime;\n      let wasPaused;\n      let isTouched;\n      let pausedByTouch;\n      let touchStartTimeout;\n      let slideChanged;\n      let pausedByInteraction;\n      function onTransitionEnd(e) {\n        if (!swiper || swiper.destroyed || !swiper.wrapperEl)\n          return;\n        if (e.target !== swiper.wrapperEl)\n          return;\n        swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n        resume();\n      }\n      const calcTimeLeft = () => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        if (swiper.autoplay.paused) {\n          wasPaused = true;\n        } else if (wasPaused) {\n          autoplayDelayCurrent = autoplayTimeLeft;\n          wasPaused = false;\n        }\n        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();\n        swiper.autoplay.timeLeft = timeLeft;\n        emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n        raf = requestAnimationFrame(() => {\n          calcTimeLeft();\n        });\n      };\n      const getSlideDelay = () => {\n        let activeSlideEl;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains(\"swiper-slide-active\"))[0];\n        } else {\n          activeSlideEl = swiper.slides[swiper.activeIndex];\n        }\n        if (!activeSlideEl)\n          return void 0;\n        const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n        return currentSlideDelay;\n      };\n      const run = (delayForce) => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        cancelAnimationFrame(raf);\n        calcTimeLeft();\n        let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n        autoplayDelayTotal = swiper.params.autoplay.delay;\n        autoplayDelayCurrent = swiper.params.autoplay.delay;\n        const currentSlideDelay = getSlideDelay();\n        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n          delay = currentSlideDelay;\n          autoplayDelayTotal = currentSlideDelay;\n          autoplayDelayCurrent = currentSlideDelay;\n        }\n        autoplayTimeLeft = delay;\n        const speed = swiper.params.speed;\n        const proceed = () => {\n          if (!swiper || swiper.destroyed)\n            return;\n          if (swiper.params.autoplay.reverseDirection) {\n            if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n              swiper.slidePrev(speed, true, true);\n              emit(\"autoplay\");\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n              emit(\"autoplay\");\n            }\n          } else {\n            if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n              swiper.slideNext(speed, true, true);\n              emit(\"autoplay\");\n            } else if (!swiper.params.autoplay.stopOnLastSlide) {\n              swiper.slideTo(0, speed, true, true);\n              emit(\"autoplay\");\n            }\n          }\n          if (swiper.params.cssMode) {\n            autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n            requestAnimationFrame(() => {\n              run();\n            });\n          }\n        };\n        if (delay > 0) {\n          clearTimeout(timeout2);\n          timeout2 = setTimeout(() => {\n            proceed();\n          }, delay);\n        } else {\n          requestAnimationFrame(() => {\n            proceed();\n          });\n        }\n        return delay;\n      };\n      const start = () => {\n        swiper.autoplay.running = true;\n        run();\n        emit(\"autoplayStart\");\n      };\n      const stop = () => {\n        swiper.autoplay.running = false;\n        clearTimeout(timeout2);\n        cancelAnimationFrame(raf);\n        emit(\"autoplayStop\");\n      };\n      const pause = (internal, reset) => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        clearTimeout(timeout2);\n        if (!internal) {\n          pausedByInteraction = true;\n        }\n        const proceed = () => {\n          emit(\"autoplayPause\");\n          if (swiper.params.autoplay.waitForTransition) {\n            swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n          } else {\n            resume();\n          }\n        };\n        swiper.autoplay.paused = true;\n        if (reset) {\n          if (slideChanged) {\n            autoplayTimeLeft = swiper.params.autoplay.delay;\n          }\n          slideChanged = false;\n          proceed();\n          return;\n        }\n        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n        autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)\n          return;\n        if (autoplayTimeLeft < 0)\n          autoplayTimeLeft = 0;\n        proceed();\n      };\n      const resume = () => {\n        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running)\n          return;\n        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n        if (pausedByInteraction) {\n          pausedByInteraction = false;\n          run(autoplayTimeLeft);\n        } else {\n          run();\n        }\n        swiper.autoplay.paused = false;\n        emit(\"autoplayResume\");\n      };\n      const onVisibilityChange = () => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        const document2 = getDocument();\n        if (document2.visibilityState === \"hidden\") {\n          pausedByInteraction = true;\n          pause(true);\n        }\n        if (document2.visibilityState === \"visible\") {\n          resume();\n        }\n      };\n      const onPointerEnter = (e) => {\n        if (e.pointerType !== \"mouse\")\n          return;\n        pausedByInteraction = true;\n        pause(true);\n      };\n      const onPointerLeave = (e) => {\n        if (e.pointerType !== \"mouse\")\n          return;\n        if (swiper.autoplay.paused) {\n          resume();\n        }\n      };\n      const attachMouseEvents = () => {\n        if (swiper.params.autoplay.pauseOnMouseEnter) {\n          swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n          swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n        }\n      };\n      const detachMouseEvents = () => {\n        swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n        swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n      };\n      const attachDocumentEvents = () => {\n        const document2 = getDocument();\n        document2.addEventListener(\"visibilitychange\", onVisibilityChange);\n      };\n      const detachDocumentEvents = () => {\n        const document2 = getDocument();\n        document2.removeEventListener(\"visibilitychange\", onVisibilityChange);\n      };\n      on(\"init\", () => {\n        if (swiper.params.autoplay.enabled) {\n          attachMouseEvents();\n          attachDocumentEvents();\n          autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();\n          start();\n        }\n      });\n      on(\"destroy\", () => {\n        detachMouseEvents();\n        detachDocumentEvents();\n        if (swiper.autoplay.running) {\n          stop();\n        }\n      });\n      on(\"beforeTransitionStart\", (_s, speed, internal) => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          pause(true, true);\n        } else {\n          stop();\n        }\n      });\n      on(\"sliderFirstMove\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        if (swiper.params.autoplay.disableOnInteraction) {\n          stop();\n          return;\n        }\n        isTouched = true;\n        pausedByTouch = false;\n        pausedByInteraction = false;\n        touchStartTimeout = setTimeout(() => {\n          pausedByInteraction = true;\n          pausedByTouch = true;\n          pause(true);\n        }, 200);\n      });\n      on(\"touchEnd\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running || !isTouched)\n          return;\n        clearTimeout(touchStartTimeout);\n        clearTimeout(timeout2);\n        if (swiper.params.autoplay.disableOnInteraction) {\n          pausedByTouch = false;\n          isTouched = false;\n          return;\n        }\n        if (pausedByTouch && swiper.params.cssMode)\n          resume();\n        pausedByTouch = false;\n        isTouched = false;\n      });\n      on(\"slideChange\", () => {\n        if (swiper.destroyed || !swiper.autoplay.running)\n          return;\n        slideChanged = true;\n      });\n      Object.assign(swiper.autoplay, {\n        start,\n        stop,\n        pause,\n        resume\n      });\n    }\n    function Thumb({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        thumbs: {\n          swiper: null,\n          multipleActiveThumbs: true,\n          autoScrollOffset: 0,\n          slideThumbActiveClass: \"swiper-slide-thumb-active\",\n          thumbsContainerClass: \"swiper-thumbs\"\n        }\n      });\n      let initialized = false;\n      let swiperCreated = false;\n      swiper.thumbs = {\n        swiper: null\n      };\n      function onThumbClick() {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed)\n          return;\n        const clickedIndex = thumbsSwiper.clickedIndex;\n        const clickedSlide = thumbsSwiper.clickedSlide;\n        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass))\n          return;\n        if (typeof clickedIndex === \"undefined\" || clickedIndex === null)\n          return;\n        let slideToIndex;\n        if (thumbsSwiper.params.loop) {\n          slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n        } else {\n          slideToIndex = clickedIndex;\n        }\n        if (swiper.params.loop) {\n          swiper.slideToLoop(slideToIndex);\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      }\n      function init() {\n        const {\n          thumbs: thumbsParams\n        } = swiper.params;\n        if (initialized)\n          return false;\n        initialized = true;\n        const SwiperClass = swiper.constructor;\n        if (thumbsParams.swiper instanceof SwiperClass) {\n          swiper.thumbs.swiper = thumbsParams.swiper;\n          Object.assign(swiper.thumbs.swiper.originalParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          Object.assign(swiper.thumbs.swiper.params, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper.update();\n        } else if (isObject(thumbsParams.swiper)) {\n          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n          Object.assign(thumbsSwiperParams, {\n            watchSlidesProgress: true,\n            slideToClickedSlide: false\n          });\n          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n          swiperCreated = true;\n        }\n        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n        swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n        return true;\n      }\n      function update2(initial) {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed)\n          return;\n        const slidesPerView = thumbsSwiper.params.slidesPerView === \"auto\" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n        let thumbsToActivate = 1;\n        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n          thumbsToActivate = swiper.params.slidesPerView;\n        }\n        if (!swiper.params.thumbs.multipleActiveThumbs) {\n          thumbsToActivate = 1;\n        }\n        thumbsToActivate = Math.floor(thumbsToActivate);\n        thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));\n        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach((slideEl) => {\n              slideEl.classList.add(thumbActiveClass);\n            });\n          }\n        } else {\n          for (let i = 0; i < thumbsToActivate; i += 1) {\n            if (thumbsSwiper.slides[swiper.realIndex + i]) {\n              thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n          }\n        }\n        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n          const currentThumbsIndex = thumbsSwiper.activeIndex;\n          let newThumbsIndex;\n          let direction;\n          if (thumbsSwiper.params.loop) {\n            const newThumbsSlide = thumbsSwiper.slides.filter((slideEl) => slideEl.getAttribute(\"data-swiper-slide-index\") === `${swiper.realIndex}`)[0];\n            newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n            direction = swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n          } else {\n            newThumbsIndex = swiper.realIndex;\n            direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n          }\n          if (useOffset) {\n            newThumbsIndex += direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n          }\n          if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n            if (thumbsSwiper.params.centeredSlides) {\n              if (newThumbsIndex > currentThumbsIndex) {\n                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n              } else {\n                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n              }\n            } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {\n            }\n            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);\n          }\n        }\n      }\n      on(\"beforeInit\", () => {\n        const {\n          thumbs\n        } = swiper.params;\n        if (!thumbs || !thumbs.swiper)\n          return;\n        if (typeof thumbs.swiper === \"string\" || thumbs.swiper instanceof HTMLElement) {\n          const document2 = getDocument();\n          const getThumbsElementAndInit = () => {\n            const thumbsElement = typeof thumbs.swiper === \"string\" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;\n            if (thumbsElement && thumbsElement.swiper) {\n              thumbs.swiper = thumbsElement.swiper;\n              init();\n              update2(true);\n            } else if (thumbsElement) {\n              const onThumbsSwiper = (e) => {\n                thumbs.swiper = e.detail[0];\n                thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n                init();\n                update2(true);\n                thumbs.swiper.update();\n                swiper.update();\n              };\n              thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n            }\n            return thumbsElement;\n          };\n          const watchForThumbsToAppear = () => {\n            if (swiper.destroyed)\n              return;\n            const thumbsElement = getThumbsElementAndInit();\n            if (!thumbsElement) {\n              requestAnimationFrame(watchForThumbsToAppear);\n            }\n          };\n          requestAnimationFrame(watchForThumbsToAppear);\n        } else {\n          init();\n          update2(true);\n        }\n      });\n      on(\"slideChange update resize observerUpdate\", () => {\n        update2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed)\n          return;\n        thumbsSwiper.setTransition(duration);\n      });\n      on(\"beforeDestroy\", () => {\n        const thumbsSwiper = swiper.thumbs.swiper;\n        if (!thumbsSwiper || thumbsSwiper.destroyed)\n          return;\n        if (swiperCreated) {\n          thumbsSwiper.destroy();\n        }\n      });\n      Object.assign(swiper.thumbs, {\n        init,\n        update: update2\n      });\n    }\n    function freeMode({\n      swiper,\n      extendParams,\n      emit,\n      once\n    }) {\n      extendParams({\n        freeMode: {\n          enabled: false,\n          momentum: true,\n          momentumRatio: 1,\n          momentumBounce: true,\n          momentumBounceRatio: 1,\n          momentumVelocityRatio: 1,\n          sticky: false,\n          minimumVelocity: 0.02\n        }\n      });\n      function onTouchStart2() {\n        const translate2 = swiper.getTranslate();\n        swiper.setTranslate(translate2);\n        swiper.setTransition(0);\n        swiper.touchEventsData.velocities.length = 0;\n        swiper.freeMode.onTouchEnd({\n          currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n        });\n      }\n      function onTouchMove2() {\n        const {\n          touchEventsData: data,\n          touches\n        } = swiper;\n        if (data.velocities.length === 0) {\n          data.velocities.push({\n            position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n            time: data.touchStartTime\n          });\n        }\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n          time: now()\n        });\n      }\n      function onTouchEnd2({\n        currentPos\n      }) {\n        const {\n          params,\n          wrapperEl,\n          rtlTranslate: rtl,\n          snapGrid,\n          touchEventsData: data\n        } = swiper;\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        if (currentPos < -swiper.minTranslate()) {\n          swiper.slideTo(swiper.activeIndex);\n          return;\n        }\n        if (currentPos > -swiper.maxTranslate()) {\n          if (swiper.slides.length < snapGrid.length) {\n            swiper.slideTo(snapGrid.length - 1);\n          } else {\n            swiper.slideTo(swiper.slides.length - 1);\n          }\n          return;\n        }\n        if (params.freeMode.momentum) {\n          if (data.velocities.length > 1) {\n            const lastMoveEvent = data.velocities.pop();\n            const velocityEvent = data.velocities.pop();\n            const distance = lastMoveEvent.position - velocityEvent.position;\n            const time = lastMoveEvent.time - velocityEvent.time;\n            swiper.velocity = distance / time;\n            swiper.velocity /= 2;\n            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n              swiper.velocity = 0;\n            }\n            if (time > 150 || now() - lastMoveEvent.time > 300) {\n              swiper.velocity = 0;\n            }\n          } else {\n            swiper.velocity = 0;\n          }\n          swiper.velocity *= params.freeMode.momentumVelocityRatio;\n          data.velocities.length = 0;\n          let momentumDuration = 1e3 * params.freeMode.momentumRatio;\n          const momentumDistance = swiper.velocity * momentumDuration;\n          let newPosition = swiper.translate + momentumDistance;\n          if (rtl)\n            newPosition = -newPosition;\n          let doBounce = false;\n          let afterBouncePosition;\n          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n          let needsLoopFix;\n          if (newPosition < swiper.maxTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n                newPosition = swiper.maxTranslate() - bounceAmount;\n              }\n              afterBouncePosition = swiper.maxTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.maxTranslate();\n            }\n            if (params.loop && params.centeredSlides)\n              needsLoopFix = true;\n          } else if (newPosition > swiper.minTranslate()) {\n            if (params.freeMode.momentumBounce) {\n              if (newPosition - swiper.minTranslate() > bounceAmount) {\n                newPosition = swiper.minTranslate() + bounceAmount;\n              }\n              afterBouncePosition = swiper.minTranslate();\n              doBounce = true;\n              data.allowMomentumBounce = true;\n            } else {\n              newPosition = swiper.minTranslate();\n            }\n            if (params.loop && params.centeredSlides)\n              needsLoopFix = true;\n          } else if (params.freeMode.sticky) {\n            let nextSlide;\n            for (let j = 0; j < snapGrid.length; j += 1) {\n              if (snapGrid[j] > -newPosition) {\n                nextSlide = j;\n                break;\n              }\n            }\n            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === \"next\") {\n              newPosition = snapGrid[nextSlide];\n            } else {\n              newPosition = snapGrid[nextSlide - 1];\n            }\n            newPosition = -newPosition;\n          }\n          if (needsLoopFix) {\n            once(\"transitionEnd\", () => {\n              swiper.loopFix();\n            });\n          }\n          if (swiper.velocity !== 0) {\n            if (rtl) {\n              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n            } else {\n              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n            }\n            if (params.freeMode.sticky) {\n              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n              if (moveDistance < currentSlideSize) {\n                momentumDuration = params.speed;\n              } else if (moveDistance < 2 * currentSlideSize) {\n                momentumDuration = params.speed * 1.5;\n              } else {\n                momentumDuration = params.speed * 2.5;\n              }\n            }\n          } else if (params.freeMode.sticky) {\n            swiper.slideToClosest();\n            return;\n          }\n          if (params.freeMode.momentumBounce && doBounce) {\n            swiper.updateProgress(afterBouncePosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed || !data.allowMomentumBounce)\n                return;\n              emit(\"momentumBounce\");\n              swiper.setTransition(params.speed);\n              setTimeout(() => {\n                swiper.setTranslate(afterBouncePosition);\n                elementTransitionEnd(wrapperEl, () => {\n                  if (!swiper || swiper.destroyed)\n                    return;\n                  swiper.transitionEnd();\n                });\n              }, 0);\n            });\n          } else if (swiper.velocity) {\n            emit(\"_freeModeNoMomentumRelease\");\n            swiper.updateProgress(newPosition);\n            swiper.setTransition(momentumDuration);\n            swiper.setTranslate(newPosition);\n            swiper.transitionStart(true, swiper.swipeDirection);\n            if (!swiper.animating) {\n              swiper.animating = true;\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed)\n                  return;\n                swiper.transitionEnd();\n              });\n            }\n          } else {\n            swiper.updateProgress(newPosition);\n          }\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        } else if (params.freeMode) {\n          emit(\"_freeModeNoMomentumRelease\");\n        }\n        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n        }\n      }\n      Object.assign(swiper, {\n        freeMode: {\n          onTouchStart: onTouchStart2,\n          onTouchMove: onTouchMove2,\n          onTouchEnd: onTouchEnd2\n        }\n      });\n    }\n    function Grid({\n      swiper,\n      extendParams\n    }) {\n      extendParams({\n        grid: {\n          rows: 1,\n          fill: \"column\"\n        }\n      });\n      let slidesNumberEvenToRows;\n      let slidesPerRow;\n      let numFullColumns;\n      const initSlides = (slidesLength) => {\n        const {\n          slidesPerView\n        } = swiper.params;\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        slidesPerRow = slidesNumberEvenToRows / rows;\n        numFullColumns = Math.floor(slidesLength / rows);\n        if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n          slidesNumberEvenToRows = slidesLength;\n        } else {\n          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n        }\n        if (slidesPerView !== \"auto\" && fill === \"row\") {\n          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n        }\n      };\n      const updateSlide = (i, slide2, slidesLength, getDirectionLabel) => {\n        const {\n          slidesPerGroup,\n          spaceBetween\n        } = swiper.params;\n        const {\n          rows,\n          fill\n        } = swiper.params.grid;\n        let newSlideOrderIndex;\n        let column;\n        let row;\n        if (fill === \"row\" && slidesPerGroup > 1) {\n          const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n          const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n          row = Math.floor(slideIndexInGroup / columnsInGroup);\n          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n          newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n          slide2.style.order = newSlideOrderIndex;\n        } else if (fill === \"column\") {\n          column = Math.floor(i / rows);\n          row = i - column * rows;\n          if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n            row += 1;\n            if (row >= rows) {\n              row = 0;\n              column += 1;\n            }\n          }\n        } else {\n          row = Math.floor(i / slidesPerRow);\n          column = i - row * slidesPerRow;\n        }\n        slide2.style[getDirectionLabel(\"margin-top\")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n      };\n      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n        const {\n          spaceBetween,\n          centeredSlides,\n          roundLengths\n        } = swiper.params;\n        const {\n          rows\n        } = swiper.params.grid;\n        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n        swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n        if (centeredSlides) {\n          const newSlidesGrid = [];\n          for (let i = 0; i < snapGrid.length; i += 1) {\n            let slidesGridItem = snapGrid[i];\n            if (roundLengths)\n              slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] < swiper.virtualSize + snapGrid[0])\n              newSlidesGrid.push(slidesGridItem);\n          }\n          snapGrid.splice(0, snapGrid.length);\n          snapGrid.push(...newSlidesGrid);\n        }\n      };\n      swiper.grid = {\n        initSlides,\n        updateSlide,\n        updateWrapperSize\n      };\n    }\n    function appendSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      const appendElement = (slideEl) => {\n        if (typeof slideEl === \"string\") {\n          const tempDOM = document.createElement(\"div\");\n          tempDOM.innerHTML = slideEl;\n          slidesEl.append(tempDOM.children[0]);\n          tempDOM.innerHTML = \"\";\n        } else {\n          slidesEl.append(slideEl);\n        }\n      };\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i])\n            appendElement(slides[i]);\n        }\n      } else {\n        appendElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n    }\n    function prependSlide(slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndex + 1;\n      const prependElement = (slideEl) => {\n        if (typeof slideEl === \"string\") {\n          const tempDOM = document.createElement(\"div\");\n          tempDOM.innerHTML = slideEl;\n          slidesEl.prepend(tempDOM.children[0]);\n          tempDOM.innerHTML = \"\";\n        } else {\n          slidesEl.prepend(slideEl);\n        }\n      };\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i])\n            prependElement(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n      } else {\n        prependElement(slides);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function addSlide(index, slides) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex,\n        slidesEl\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n        swiper.recalcSlides();\n      }\n      const baseLength = swiper.slides.length;\n      if (index <= 0) {\n        swiper.prependSlide(slides);\n        return;\n      }\n      if (index >= baseLength) {\n        swiper.appendSlide(slides);\n        return;\n      }\n      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n      const slidesBuffer = [];\n      for (let i = baseLength - 1; i >= index; i -= 1) {\n        const currentSlide = swiper.slides[i];\n        currentSlide.remove();\n        slidesBuffer.unshift(currentSlide);\n      }\n      if (typeof slides === \"object\" && \"length\" in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i])\n            slidesEl.append(slides[i]);\n        }\n        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n      } else {\n        slidesEl.append(slides);\n      }\n      for (let i = 0; i < slidesBuffer.length; i += 1) {\n        slidesEl.append(slidesBuffer[i]);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n    function removeSlide(slidesIndexes) {\n      const swiper = this;\n      const {\n        params,\n        activeIndex\n      } = swiper;\n      let activeIndexBuffer = activeIndex;\n      if (params.loop) {\n        activeIndexBuffer -= swiper.loopedSlides;\n        swiper.loopDestroy();\n      }\n      let newActiveIndex = activeIndexBuffer;\n      let indexToRemove;\n      if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n        for (let i = 0; i < slidesIndexes.length; i += 1) {\n          indexToRemove = slidesIndexes[i];\n          if (swiper.slides[indexToRemove])\n            swiper.slides[indexToRemove].remove();\n          if (indexToRemove < newActiveIndex)\n            newActiveIndex -= 1;\n        }\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      } else {\n        indexToRemove = slidesIndexes;\n        if (swiper.slides[indexToRemove])\n          swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex)\n          newActiveIndex -= 1;\n        newActiveIndex = Math.max(newActiveIndex, 0);\n      }\n      swiper.recalcSlides();\n      if (params.loop) {\n        swiper.loopCreate();\n      }\n      if (!params.observer || swiper.isElement) {\n        swiper.update();\n      }\n      if (params.loop) {\n        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n      } else {\n        swiper.slideTo(newActiveIndex, 0, false);\n      }\n    }\n    function removeAllSlides() {\n      const swiper = this;\n      const slidesIndexes = [];\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        slidesIndexes.push(i);\n      }\n      swiper.removeSlide(slidesIndexes);\n    }\n    function Manipulation({\n      swiper\n    }) {\n      Object.assign(swiper, {\n        appendSlide: appendSlide.bind(swiper),\n        prependSlide: prependSlide.bind(swiper),\n        addSlide: addSlide.bind(swiper),\n        removeSlide: removeSlide.bind(swiper),\n        removeAllSlides: removeAllSlides.bind(swiper)\n      });\n    }\n    function effectInit(params) {\n      const {\n        effect,\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        overwriteParams,\n        perspective,\n        recreateShadows,\n        getEffectParams\n      } = params;\n      on(\"beforeInit\", () => {\n        if (swiper.params.effect !== effect)\n          return;\n        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n        if (perspective && perspective()) {\n          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n        }\n        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n        Object.assign(swiper.params, overwriteParamsResult);\n        Object.assign(swiper.originalParams, overwriteParamsResult);\n      });\n      on(\"setTranslate\", () => {\n        if (swiper.params.effect !== effect)\n          return;\n        setTranslate2();\n      });\n      on(\"setTransition\", (_s, duration) => {\n        if (swiper.params.effect !== effect)\n          return;\n        setTransition2(duration);\n      });\n      on(\"transitionEnd\", () => {\n        if (swiper.params.effect !== effect)\n          return;\n        if (recreateShadows) {\n          if (!getEffectParams || !getEffectParams().slideShadows)\n            return;\n          swiper.slides.forEach((slideEl) => {\n            slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => shadowEl.remove());\n          });\n          recreateShadows();\n        }\n      });\n      let requireUpdateOnVirtual;\n      on(\"virtualUpdate\", () => {\n        if (swiper.params.effect !== effect)\n          return;\n        if (!swiper.slides.length) {\n          requireUpdateOnVirtual = true;\n        }\n        requestAnimationFrame(() => {\n          if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n            setTranslate2();\n            requireUpdateOnVirtual = false;\n          }\n        });\n      });\n    }\n    function effectTarget(effectParams, slideEl) {\n      const transformEl = getSlideTransformEl(slideEl);\n      if (transformEl !== slideEl) {\n        transformEl.style.backfaceVisibility = \"hidden\";\n        transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n      }\n      return transformEl;\n    }\n    function effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides\n    }) {\n      const {\n        activeIndex\n      } = swiper;\n      const getSlide = (el) => {\n        if (!el.parentElement) {\n          const slide2 = swiper.slides.filter((slideEl) => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];\n          return slide2;\n        }\n        return el.parentElement;\n      };\n      if (swiper.params.virtualTranslate && duration !== 0) {\n        let eventTriggered = false;\n        let transitionEndTarget;\n        if (allSlides) {\n          transitionEndTarget = transformElements;\n        } else {\n          transitionEndTarget = transformElements.filter((transformEl) => {\n            const el = transformEl.classList.contains(\"swiper-slide-transform\") ? getSlide(transformEl) : transformEl;\n            return swiper.getSlideIndex(el) === activeIndex;\n          });\n        }\n        transitionEndTarget.forEach((el) => {\n          elementTransitionEnd(el, () => {\n            if (eventTriggered)\n              return;\n            if (!swiper || swiper.destroyed)\n              return;\n            eventTriggered = true;\n            swiper.animating = false;\n            const evt = new window.CustomEvent(\"transitionend\", {\n              bubbles: true,\n              cancelable: true\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n          });\n        });\n      }\n    }\n    function EffectFade({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        fadeEffect: {\n          crossFade: false\n        }\n      });\n      const setTranslate2 = () => {\n        const {\n          slides\n        } = swiper;\n        const params = swiper.params.fadeEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = swiper.slides[i];\n          const offset = slideEl.swiperSlideOffset;\n          let tx = -offset;\n          if (!swiper.params.virtualTranslate)\n            tx -= swiper.translate;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n          }\n          const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.opacity = slideOpacity;\n          targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: \"fade\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n    function EffectCube({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        cubeEffect: {\n          slideShadows: true,\n          shadow: true,\n          shadowOffset: 20,\n          shadowScale: 0.94\n        }\n      });\n      const createSlideShadows = (slideEl, progress, isHorizontal) => {\n        let shadowBefore = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n        let shadowAfter = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n        if (!shadowBefore) {\n          shadowBefore = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`);\n          slideEl.append(shadowBefore);\n        }\n        if (!shadowAfter) {\n          shadowAfter = createElement(\"div\", `swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`);\n          slideEl.append(shadowAfter);\n        }\n        if (shadowBefore)\n          shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter)\n          shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        const isHorizontal = swiper.isHorizontal();\n        swiper.slides.forEach((slideEl) => {\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          createSlideShadows(slideEl, progress, isHorizontal);\n        });\n      };\n      const setTranslate2 = () => {\n        const {\n          el,\n          wrapperEl,\n          slides,\n          width: swiperWidth,\n          height: swiperHeight,\n          rtlTranslate: rtl,\n          size: swiperSize,\n          browser: browser2\n        } = swiper;\n        const params = swiper.params.cubeEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let wrapperRotate = 0;\n        let cubeShadowEl;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl = swiper.slidesEl.querySelector(\".swiper-cube-shadow\");\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n              swiper.slidesEl.append(cubeShadowEl);\n            }\n            cubeShadowEl.style.height = `${swiperWidth}px`;\n          } else {\n            cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n            if (!cubeShadowEl) {\n              cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n              el.append(cubeShadowEl);\n            }\n          }\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let slideIndex = i;\n          if (isVirtual) {\n            slideIndex = parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10);\n          }\n          let slideAngle = slideIndex * 90;\n          let round = Math.floor(slideAngle / 360);\n          if (rtl) {\n            slideAngle = -slideAngle;\n            round = Math.floor(-slideAngle / 360);\n          }\n          const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          let tx = 0;\n          let ty = 0;\n          let tz = 0;\n          if (slideIndex % 4 === 0) {\n            tx = -round * 4 * swiperSize;\n            tz = 0;\n          } else if ((slideIndex - 1) % 4 === 0) {\n            tx = 0;\n            tz = -round * 4 * swiperSize;\n          } else if ((slideIndex - 2) % 4 === 0) {\n            tx = swiperSize + round * 4 * swiperSize;\n            tz = swiperSize;\n          } else if ((slideIndex - 3) % 4 === 0) {\n            tx = -swiperSize;\n            tz = 3 * swiperSize + swiperSize * 4 * round;\n          }\n          if (rtl) {\n            tx = -tx;\n          }\n          if (!isHorizontal) {\n            ty = tx;\n            tx = 0;\n          }\n          const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n          if (progress <= 1 && progress > -1) {\n            wrapperRotate = slideIndex * 90 + progress * 90;\n            if (rtl)\n              wrapperRotate = -slideIndex * 90 - progress * 90;\n          }\n          slideEl.style.transform = transform;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, isHorizontal);\n          }\n        }\n        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n        wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${swiperSize / 2}px`;\n        if (params.shadow) {\n          if (isHorizontal) {\n            cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n          } else {\n            const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n            const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n            const scale1 = params.shadowScale;\n            const scale2 = params.shadowScale / multiplier;\n            const offset = params.shadowOffset;\n            cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n          }\n        }\n        const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;\n        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n        wrapperEl.style.setProperty(\"--swiper-cube-translate-z\", `${zFactor}px`);\n      };\n      const setTransition2 = (duration) => {\n        const {\n          el,\n          slides\n        } = swiper;\n        slides.forEach((slideEl) => {\n          slideEl.style.transitionDuration = `${duration}ms`;\n          slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((subEl) => {\n            subEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n          const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n          if (shadowEl)\n            shadowEl.style.transitionDuration = `${duration}ms`;\n        }\n      };\n      effectInit({\n        effect: \"cube\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        recreateShadows,\n        getEffectParams: () => swiper.params.cubeEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          resistanceRatio: 0,\n          spaceBetween: 0,\n          centeredSlides: false,\n          virtualTranslate: true\n        })\n      });\n    }\n    function createShadow(params, slideEl, side) {\n      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}`;\n      const shadowContainer = getSlideTransformEl(slideEl);\n      let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);\n      if (!shadowEl) {\n        shadowEl = createElement(\"div\", `swiper-slide-shadow${side ? `-${side}` : \"\"}`);\n        shadowContainer.append(shadowEl);\n      }\n      return shadowEl;\n    }\n    function EffectFlip({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        flipEffect: {\n          slideShadows: true,\n          limitRotation: true\n        }\n      });\n      const createSlideShadows = (slideEl, progress, params) => {\n        let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n        let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n        if (!shadowBefore) {\n          shadowBefore = createShadow(params, slideEl, swiper.isHorizontal() ? \"left\" : \"top\");\n        }\n        if (!shadowAfter) {\n          shadowAfter = createShadow(params, slideEl, swiper.isHorizontal() ? \"right\" : \"bottom\");\n        }\n        if (shadowBefore)\n          shadowBefore.style.opacity = Math.max(-progress, 0);\n        if (shadowAfter)\n          shadowAfter.style.opacity = Math.max(progress, 0);\n      };\n      const recreateShadows = () => {\n        const params = swiper.params.flipEffect;\n        swiper.slides.forEach((slideEl) => {\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          createSlideShadows(slideEl, progress, params);\n        });\n      };\n      const setTranslate2 = () => {\n        const {\n          slides,\n          rtlTranslate: rtl\n        } = swiper;\n        const params = swiper.params.flipEffect;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          let progress = slideEl.progress;\n          if (swiper.params.flipEffect.limitRotation) {\n            progress = Math.max(Math.min(slideEl.progress, 1), -1);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const rotate = -180 * progress;\n          let rotateY = rotate;\n          let rotateX = 0;\n          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let ty = 0;\n          if (!swiper.isHorizontal()) {\n            ty = tx;\n            tx = 0;\n            rotateX = -rotateY;\n            rotateY = 0;\n          } else if (rtl) {\n            rotateY = -rotateY;\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n          if (params.slideShadows) {\n            createSlideShadows(slideEl, progress, params);\n          }\n          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: \"flip\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        recreateShadows,\n        getEffectParams: () => swiper.params.flipEffect,\n        perspective: () => true,\n        overwriteParams: () => ({\n          slidesPerView: 1,\n          slidesPerGroup: 1,\n          watchSlidesProgress: true,\n          spaceBetween: 0,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n    function EffectCoverflow({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        coverflowEffect: {\n          rotate: 50,\n          stretch: 0,\n          depth: 100,\n          scale: 1,\n          modifier: 1,\n          slideShadows: true\n        }\n      });\n      const setTranslate2 = () => {\n        const {\n          width: swiperWidth,\n          height: swiperHeight,\n          slides,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.coverflowEffect;\n        const isHorizontal = swiper.isHorizontal();\n        const transform = swiper.translate;\n        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n        const rotate = isHorizontal ? params.rotate : -params.rotate;\n        const translate2 = params.depth;\n        for (let i = 0, length = slides.length; i < length; i += 1) {\n          const slideEl = slides[i];\n          const slideSize = slidesSizesGrid[i];\n          const slideOffset = slideEl.swiperSlideOffset;\n          const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n          const offsetMultiplier = typeof params.modifier === \"function\" ? params.modifier(centerOffset) : centerOffset * params.modifier;\n          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n          let translateZ = -translate2 * Math.abs(offsetMultiplier);\n          let stretch = params.stretch;\n          if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) {\n            stretch = parseFloat(params.stretch) / 100 * slideSize;\n          }\n          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n          if (Math.abs(translateX) < 1e-3)\n            translateX = 0;\n          if (Math.abs(translateY) < 1e-3)\n            translateY = 0;\n          if (Math.abs(translateZ) < 1e-3)\n            translateZ = 0;\n          if (Math.abs(rotateY) < 1e-3)\n            rotateY = 0;\n          if (Math.abs(rotateX) < 1e-3)\n            rotateX = 0;\n          if (Math.abs(scale) < 1e-3)\n            scale = 0;\n          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = slideTransform;\n          slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n          if (params.slideShadows) {\n            let shadowBeforeEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfterEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBeforeEl) {\n              shadowBeforeEl = createShadow(params, slideEl, isHorizontal ? \"left\" : \"top\");\n            }\n            if (!shadowAfterEl) {\n              shadowAfterEl = createShadow(params, slideEl, isHorizontal ? \"right\" : \"bottom\");\n            }\n            if (shadowBeforeEl)\n              shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n            if (shadowAfterEl)\n              shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n          }\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n      };\n      effectInit({\n        effect: \"coverflow\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true\n        })\n      });\n    }\n    function EffectCreative({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        creativeEffect: {\n          limitProgress: 1,\n          shadowPerProgress: false,\n          progressMultiplier: 1,\n          perspective: true,\n          prev: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          },\n          next: {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            opacity: 1,\n            scale: 1\n          }\n        }\n      });\n      const getTranslateValue = (value) => {\n        if (typeof value === \"string\")\n          return value;\n        return `${value}px`;\n      };\n      const setTranslate2 = () => {\n        const {\n          slides,\n          wrapperEl,\n          slidesSizesGrid\n        } = swiper;\n        const params = swiper.params.creativeEffect;\n        const {\n          progressMultiplier: multiplier\n        } = params;\n        const isCenteredSlides = swiper.params.centeredSlides;\n        if (isCenteredSlides) {\n          const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n          wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n        }\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n          let originalProgress = progress;\n          if (!isCenteredSlides) {\n            originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n          }\n          const offset = slideEl.swiperSlideOffset;\n          const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n          const r = [0, 0, 0];\n          let custom = false;\n          if (!swiper.isHorizontal()) {\n            t[1] = t[0];\n            t[0] = 0;\n          }\n          let data = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: 1,\n            opacity: 1\n          };\n          if (progress < 0) {\n            data = params.next;\n            custom = true;\n          } else if (progress > 0) {\n            data = params.prev;\n            custom = true;\n          }\n          t.forEach((value, index) => {\n            t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n          });\n          r.forEach((value, index) => {\n            r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n          });\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const translateString = t.join(\", \");\n          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n          const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n          const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n          if (custom && data.shadow || !custom) {\n            let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n            if (!shadowEl && data.shadow) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl) {\n              const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n              shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n            }\n          }\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n          targetEl.style.opacity = opacityString;\n          if (data.origin) {\n            targetEl.style.transformOrigin = data.origin;\n          }\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements,\n          allSlides: true\n        });\n      };\n      effectInit({\n        effect: \"creative\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => swiper.params.creativeEffect.perspective,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n    function EffectCards({\n      swiper,\n      extendParams,\n      on\n    }) {\n      extendParams({\n        cardsEffect: {\n          slideShadows: true,\n          rotate: true,\n          perSlideRotate: 2,\n          perSlideOffset: 8\n        }\n      });\n      const setTranslate2 = () => {\n        const {\n          slides,\n          activeIndex\n        } = swiper;\n        const params = swiper.params.cardsEffect;\n        const {\n          startTranslate,\n          isTouched\n        } = swiper.touchEventsData;\n        const currentTranslate = swiper.translate;\n        for (let i = 0; i < slides.length; i += 1) {\n          const slideEl = slides[i];\n          const slideProgress = slideEl.progress;\n          const progress = Math.min(Math.max(slideProgress, -4), 4);\n          let offset = slideEl.swiperSlideOffset;\n          if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n            swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n          }\n          if (swiper.params.centeredSlides && swiper.params.cssMode) {\n            offset -= slides[0].swiperSlideOffset;\n          }\n          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n          let tY = 0;\n          const tZ = -100 * Math.abs(progress);\n          let scale = 1;\n          let rotate = -params.perSlideRotate * progress;\n          let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n          const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n          const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n          const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n          if (isSwipeToNext || isSwipeToPrev) {\n            const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n            rotate += -28 * progress * subProgress;\n            scale += -0.5 * subProgress;\n            tXAdd += 96 * subProgress;\n            tY = `${-25 * subProgress * Math.abs(progress)}%`;\n          }\n          if (progress < 0) {\n            tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n          } else if (progress > 0) {\n            tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n          } else {\n            tX = `${tX}px`;\n          }\n          if (!swiper.isHorizontal()) {\n            const prevY = tY;\n            tY = tX;\n            tX = prevY;\n          }\n          const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n          const transform = `\n            translate3d(${tX}, ${tY}, ${tZ}px)\n            rotateZ(${params.rotate ? rotate : 0}deg)\n            scale(${scaleString})\n          `;\n          if (params.slideShadows) {\n            let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n            if (!shadowEl) {\n              shadowEl = createShadow(params, slideEl);\n            }\n            if (shadowEl)\n              shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n          }\n          slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n          const targetEl = effectTarget(params, slideEl);\n          targetEl.style.transform = transform;\n        }\n      };\n      const setTransition2 = (duration) => {\n        const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));\n        transformElements.forEach((el) => {\n          el.style.transitionDuration = `${duration}ms`;\n          el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl) => {\n            shadowEl.style.transitionDuration = `${duration}ms`;\n          });\n        });\n        effectVirtualTransitionEnd({\n          swiper,\n          duration,\n          transformElements\n        });\n      };\n      effectInit({\n        effect: \"cards\",\n        swiper,\n        on,\n        setTranslate: setTranslate2,\n        setTransition: setTransition2,\n        perspective: () => true,\n        overwriteParams: () => ({\n          watchSlidesProgress: true,\n          virtualTranslate: !swiper.params.cssMode\n        })\n      });\n    }\n    window.addEventListener(\"DOMContentLoaded\", () => {\n      const vacanyTitle = () => {\n        const vacancyTitleEl = document.querySelector(\".tmpl_hh_content p:first-of-type\");\n        if (vacancyTitleEl) {\n            vacancyTitleEl.classList.add(\"tmpl_hh_content_vacancy-title\");\n        }\n      };\n      new Swiper(\".tmpl_hh_aside-second .swiper\", {\n        loop: true,\n        modules: [Navigation, Pagination],\n        spaceBetween: 10,\n        pagination: {\n          el: \".tmpl_hh_aside-second .swiper-pagination\",\n          clickable: true,\n          bulletClass: \"tmpl_hh_swiper__pagination-bullet\",\n          bulletActiveClass: \"tmpl_hh_swiper__pagination-bullet-active\"\n        },\n        navigation: {\n          nextEl: \".tmpl_hh_aside-second .swiper-button-next\",\n          prevEl: \".tmpl_hh_aside-second .swiper-button-prev\"\n        }\n      });\n      vacanyTitle();\n      customTitle();\n    });\n    \n    \n    //\n    </script> ",
    "vacancy_constructor_template": null,
    "key_skills": [
        {
            "name": "Jira"
        },
        {
            "name": "Agile"
        },
        {
            "name": "Scrum"
        },
        {
            "name": "Kanban"
        },
        {
            "name": "Waterfall"
        }
    ],
    "accept_handicapped": false,
    "accept_kids": false,
    "archived": false,
    "response_url": null,
    "specializations": [],
    "professional_roles": [
        {
            "id": "73",
            "name": "Менеджер продукта"
        }
    ],
    "code": null,
    "hidden": false,
    "quick_responses_allowed": false,
    "driver_license_types": [],
    "accept_incomplete_resumes": false,
    "employer": {
        "id": "4649269",
        "name": "Т1",
        "url": "https://api.hh.ru/employers/4649269",
        "alternate_url": "https://hh.ru/employer/4649269",
        "logo_urls": {
            "240": "https://img.hhcdn.ru/employer-logo/6959835.png",
            "original": "https://img.hhcdn.ru/employer-logo-original/1334956.png",
            "90": "https://img.hhcdn.ru/employer-logo/6959834.png"
        },
        "vacancies_url": "https://api.hh.ru/vacancies?employer_id=4649269",
        "accredited_it_employer": true,
        "trusted": true
    },
    "published_at": "2024-10-04T10:32:54+0300",
    "created_at": "2024-10-04T10:32:54+0300",
    "initial_created_at": "2024-09-04T10:32:53+0300",
    "negotiations_url": null,
    "suitable_resumes_url": null,
    "apply_alternate_url": "https://hh.ru/applicant/vacancy_response?vacancyId=106757940",
    "has_test": false,
    "test": null,
    "alternate_url": "https://hh.ru/vacancy/106757940",
    "working_days": [],
    "working_time_intervals": [],
    "working_time_modes": [],
    "accept_temporary": false,
    "languages": [],
    "approved": true
}
```

## Лицензия

Этот проект лицензирован под лицензией MIT. Подробности можно найти в файле LICENSE.